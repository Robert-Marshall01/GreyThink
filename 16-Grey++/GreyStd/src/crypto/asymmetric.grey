// GreyStd Crypto - Asymmetric
// Asymmetric (public-key) cryptography wrappers

// Create an RSA key pair configuration
fn RSAKeyPair_new(bits) {
  {
    _type: "RSAKeyPair",
    algorithm: "RSA",
    bits: bits,
    public_key: nil,
    private_key: nil,
    generated: false
  }
}

// Generate an RSA key pair
fn rsa_generate(bits) {
  fn pair() { generate_keypair("RSA", bits) }
  {
    _type: "RSAKeyPair",
    algorithm: "RSA",
    bits: bits,
    public_key: get(pair(), "public"),
    private_key: get(pair(), "private"),
    generated: true
  }
}

// Get public key from key pair
fn keypair_public(kp) {
  get(kp, "public_key")
}

// Get private key from key pair
fn keypair_private(kp) {
  get(kp, "private_key")
}

// Encrypt with public key
fn rsa_encrypt(plaintext, public_key) {
  encrypt_asymmetric(plaintext, public_key, "RSA")
}

// Decrypt with private key
fn rsa_decrypt(ciphertext, private_key) {
  decrypt_asymmetric(ciphertext, private_key, "RSA")
}

// Sign data with private key
fn rsa_sign(data, private_key) {
  sign(data, private_key, "RSA-SHA256")
}

// Verify signature with public key
fn rsa_verify(data, signature, public_key) {
  verify_signature(data, signature, public_key, "RSA-SHA256")
}

// Create an EC key pair (Elliptic Curve)
fn ec_generate(curve) {
  fn pair() { generate_keypair("EC", curve) }
  {
    _type: "ECKeyPair",
    algorithm: "EC",
    curve: curve,
    public_key: get(pair(), "public"),
    private_key: get(pair(), "private"),
    generated: true
  }
}

// ECDSA sign
fn ecdsa_sign(data, private_key) {
  sign(data, private_key, "ECDSA")
}

// ECDSA verify
fn ecdsa_verify(data, signature, public_key) {
  verify_signature(data, signature, public_key, "ECDSA")
}

// Export public key as PEM-like string
fn key_to_pem(key, key_type) {
  fn header() { concat_str("-----BEGIN ", upper(key_type), " KEY-----") }
  fn footer() { concat_str("-----END ", upper(key_type), " KEY-----") }
  concat_str(header(), "\n", to_string(key), "\n", footer())
}

// Create a simple digital envelope (encrypt data + key)
fn seal(plaintext, recipient_public_key) {
  fn session_key() { random_hex(32) }
  fn encrypted_data() { encrypt(plaintext, session_key(), "AES-256-CBC") }
  fn encrypted_key() { rsa_encrypt(session_key(), recipient_public_key) }
  {
    _type: "SealedEnvelope",
    encrypted_data: encrypted_data(),
    encrypted_key: encrypted_key()
  }
}

// Open a sealed envelope
fn unseal(envelope, private_key) {
  fn session_key() { rsa_decrypt(get(envelope, "encrypted_key"), private_key) }
  decrypt(get(envelope, "encrypted_data"), session_key(), "AES-256-CBC")
}

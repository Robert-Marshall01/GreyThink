/// io::stream — Core Read, Write, Seek traits and stream utilities.

use crate::core::option::Option;
use crate::core::result::Result;
use crate::core::string::String;
use crate::core::vec::Vec;
use crate::io::{IoResult, IoError, IoErrorKind};

/// A trait for reading bytes from a source.
pub trait Read {
    /// Reads bytes into `buf`, returning the number of bytes read.
    /// Returns 0 at EOF.
    fn read(mut self, buf: &mut [u8]) -> IoResult<usize>;

    /// Reads exactly `buf.len()` bytes, returning an error if EOF is reached early.
    fn read_exact(mut self, buf: &mut [u8]) -> IoResult<()> {
        let mut filled = 0;
        while filled < buf.len() {
            match self.read(&mut buf[filled..]) {
                Ok(0) => return Err(IoError::new(IoErrorKind::UnexpectedEof, String::from("unexpected eof"))),
                Ok(n) => filled = filled + n,
                Err(e) if e.kind() == IoErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            }
        }
        Ok(())
    }

    /// Reads all remaining bytes into a Vec.
    fn read_to_end(mut self, buf: &mut Vec<u8>) -> IoResult<usize> {
        let mut total = 0;
        let mut chunk = [0u8; 8192];
        loop {
            match self.read(&mut chunk) {
                Ok(0) => break,
                Ok(n) => {
                    buf.extend_from_slice(&chunk[..n]);
                    total = total + n;
                }
                Err(e) if e.kind() == IoErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            }
        }
        Ok(total)
    }

    /// Reads all remaining bytes as a UTF-8 string.
    fn read_to_string(mut self, buf: &mut String) -> IoResult<usize> {
        let mut bytes = Vec::new();
        let n = self.read_to_end(&mut bytes)?;
        match String::from_utf8(bytes) {
            Ok(s) => {
                buf.push_str(&s);
                Ok(n)
            }
            Err(_) => Err(IoError::new(IoErrorKind::InvalidData, String::from("invalid UTF-8"))),
        }
    }

    /// Reads a single byte. Returns None at EOF.
    fn read_byte(mut self) -> IoResult<Option<u8>> {
        let mut buf = [0u8; 1];
        match self.read(&mut buf) {
            Ok(0) => Ok(None),
            Ok(_) => Ok(Some(buf[0])),
            Err(e) => Err(e),
        }
    }

    /// Creates a reader that reads at most `limit` bytes.
    fn take(self, limit: u64) -> Take<Self> where Self: Sized {
        Take { inner: self, remaining: limit }
    }

    /// Chains this reader with another, reading from self first, then other.
    fn chain<R: Read>(self, other: R) -> Chain<Self, R> where Self: Sized {
        Chain { first: self, second: other, done_first: false }
    }

    /// Converts this reader into a byte iterator.
    fn bytes(self) -> ByteIter<Self> where Self: Sized {
        ByteIter { reader: self }
    }
}

/// A trait for writing bytes to a destination.
pub trait Write {
    /// Writes bytes from `buf`, returning the number of bytes written.
    fn write(mut self, buf: &[u8]) -> IoResult<usize>;

    /// Writes all bytes from buf, retrying on partial writes.
    fn write_all(mut self, buf: &[u8]) -> IoResult<()> {
        let mut written = 0;
        while written < buf.len() {
            match self.write(&buf[written..]) {
                Ok(0) => return Err(IoError::new(IoErrorKind::WriteZero, String::from("write returned 0"))),
                Ok(n) => written = written + n,
                Err(e) if e.kind() == IoErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            }
        }
        Ok(())
    }

    /// Writes a string.
    fn write_str(mut self, s: &str) -> IoResult<()> {
        self.write_all(s.as_bytes())
    }

    /// Writes a formatted string.
    fn write_fmt(mut self, args: Arguments) -> IoResult<()> {
        let s = format(args);
        self.write_all(s.as_bytes())
    }

    /// Flushes any buffered data.
    fn flush(mut self) -> IoResult<()>;
}

/// A trait for seeking within a stream.
pub trait Seek {
    /// Seeks to a position, returning the new position from the start.
    fn seek(mut self, pos: SeekFrom) -> IoResult<u64>;

    /// Returns the current position.
    fn stream_position(mut self) -> IoResult<u64> {
        self.seek(SeekFrom::Current(0))
    }

    /// Seeks to the start of the stream.
    fn rewind(mut self) -> IoResult<()> {
        self.seek(SeekFrom::Start(0))?;
        Ok(())
    }

    /// Returns the length of the stream.
    fn stream_len(mut self) -> IoResult<u64> {
        let old = self.stream_position()?;
        let len = self.seek(SeekFrom::End(0))?;
        if old != len {
            self.seek(SeekFrom::Start(old))?;
        }
        Ok(len)
    }
}

/// Position for seek operations.
pub enum SeekFrom {
    /// Seek from the beginning of the stream.
    Start(u64),
    /// Seek from the end of the stream.
    End(i64),
    /// Seek relative to the current position.
    Current(i64),
}

/// A trait for readers that can also read lines.
pub trait BufRead: Read {
    /// Reads bytes until the delimiter is found or EOF, including the delimiter.
    fn read_until(mut self, delim: u8, buf: &mut Vec<u8>) -> IoResult<usize>;

    /// Reads a line (up to and including '\n') into the buffer.
    fn read_line(mut self, buf: &mut String) -> IoResult<usize> {
        let mut bytes = Vec::new();
        let n = self.read_until(b'\n', &mut bytes)?;
        match String::from_utf8(bytes) {
            Ok(s) => {
                buf.push_str(&s);
                Ok(n)
            }
            Err(_) => Err(IoError::new(IoErrorKind::InvalidData, String::from("invalid UTF-8 in line"))),
        }
    }

    /// Returns an iterator over lines.
    fn lines(self) -> Lines<Self> where Self: Sized {
        Lines { reader: self }
    }
}

// ─── Adapter types ──────────────────────────────────────────

/// Reader that limits bytes read.
pub struct Take<R> {
    inner: R,
    remaining: u64,
}

impl<R: Read> Read for Take<R> {
    fn read(mut self, buf: &mut [u8]) -> IoResult<usize> {
        if self.remaining == 0 {
            return Ok(0);
        }
        let max = if buf.len() as u64 > self.remaining {
            self.remaining as usize
        } else {
            buf.len()
        };
        let n = self.inner.read(&mut buf[..max])?;
        self.remaining = self.remaining - n as u64;
        Ok(n)
    }
}

impl<R> Take<R> {
    pub fn limit(self) -> u64 { self.remaining }
    pub fn into_inner(self) -> R { self.inner }
}

/// Reader that chains two readers.
pub struct Chain<A, B> {
    first: A,
    second: B,
    done_first: bool,
}

impl<A: Read, B: Read> Read for Chain<A, B> {
    fn read(mut self, buf: &mut [u8]) -> IoResult<usize> {
        if !self.done_first {
            match self.first.read(buf) {
                Ok(0) => { self.done_first = true; }
                other => return other,
            }
        }
        self.second.read(buf)
    }
}

impl<A, B> Chain<A, B> {
    pub fn into_inner(self) -> (A, B) { (self.first, self.second) }
}

/// Byte iterator over a reader.
pub struct ByteIter<R> {
    reader: R,
}

impl<R: Read> Iterator for ByteIter<R> {
    type Item = IoResult<u8>;

    fn next(mut self) -> Option<IoResult<u8>> {
        match self.reader.read_byte() {
            Ok(Some(b)) => Some(Ok(b)),
            Ok(None) => None,
            Err(e) => Some(Err(e)),
        }
    }
}

/// Line iterator over a BufRead.
pub struct Lines<R> {
    reader: R,
}

impl<R: BufRead> Iterator for Lines<R> {
    type Item = IoResult<String>;

    fn next(mut self) -> Option<IoResult<String>> {
        let mut line = String::new();
        match self.reader.read_line(&mut line) {
            Ok(0) => None,
            Ok(_) => {
                // Strip trailing newline
                if line.ends_with('\n') {
                    line.pop();
                    if line.ends_with('\r') {
                        line.pop();
                    }
                }
                Some(Ok(line))
            }
            Err(e) => Some(Err(e)),
        }
    }
}

// ─── Utility streams ────────────────────────────────────────

/// Returns a reader that always returns EOF (reads 0 bytes).
pub fn empty() -> Empty { Empty }

pub struct Empty;

impl Read for Empty {
    fn read(self, _buf: &mut [u8]) -> IoResult<usize> { Ok(0) }
}

/// Returns a reader that yields infinite copies of a single byte.
pub fn repeat(byte: u8) -> Repeat { Repeat { byte } }

pub struct Repeat { byte: u8 }

impl Read for Repeat {
    fn read(self, buf: &mut [u8]) -> IoResult<usize> {
        for b in buf.iter_mut() {
            *b = self.byte;
        }
        Ok(buf.len())
    }
}

/// Returns a writer that discards all data written to it.
pub fn sink() -> Sink { Sink }

pub struct Sink;

impl Write for Sink {
    fn write(self, buf: &[u8]) -> IoResult<usize> { Ok(buf.len()) }
    fn flush(self) -> IoResult<()> { Ok(()) }
}

/// Copies all bytes from `reader` to `writer`, returning the total copied.
pub fn copy<R: Read, W: Write>(reader: &mut R, writer: &mut W) -> IoResult<u64> {
    let mut total: u64 = 0;
    let mut buf = [0u8; 8192];
    loop {
        match reader.read(&mut buf) {
            Ok(0) => break,
            Ok(n) => {
                writer.write_all(&buf[..n])?;
                total = total + n as u64;
            }
            Err(e) if e.kind() == IoErrorKind::Interrupted => continue,
            Err(e) => return Err(e),
        }
    }
    Ok(total)
}

/// Read + Write + Seek combined  (for convenience bounds).
pub trait ReadWriteSeek: Read + Write + Seek {}
impl<T: Read + Write + Seek> ReadWriteSeek for T {}

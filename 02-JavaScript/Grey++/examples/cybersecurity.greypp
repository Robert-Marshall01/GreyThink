// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Grey++ Cybersecurity â€” Encryption, Firewalls, Auth, Threat Detection
// Replaces: Python (security tools), C (crypto), Go (network security)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

section("GREY++ CYBERSECURITY")

// â”€â”€ 1. Cryptography Primitives â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
section("1. Cryptography Primitives")

fn caesar_encrypt(text, shift) {
    fn chars() { split(text, "") }
    fn shift_char(ch) {
        fn code() { to_number(ch) }
        // Simple character shift for demonstration
        fn is_alpha() { or(and(ch >= "a", ch <= "z"), and(ch >= "A", ch <= "Z")) }
        if_then(is_alpha(),
            fn() {
                fn base() { if_then(and(ch >= "a", ch <= "z"), 97, 65) }
                // Simplified: rotate through alphabet
                fn idx() { index_of(split("abcdefghijklmnopqrstuvwxyz", ""), lower(ch)) }
                fn new_idx() { mod(idx() + shift, 26) }
                fn new_char() { get(split("abcdefghijklmnopqrstuvwxyz", ""), new_idx()) }
                if_then(and(ch >= "A", ch <= "Z"), upper(new_char()), new_char())
            },
            ch
        )
    }
    join(map(chars(), fn(c) { shift_char(c) }), "")
}

fn xor_encrypt(text, key) {
    fn text_chars() { split(text, "") }
    fn key_chars() { split(key, "") }
    fn key_len() { len(key_chars()) }
    join(map(range(0, len(text_chars())), fn(i) {
        fn t_code() { to_number(char_at(text, i)) }
        fn k_code() { to_number(char_at(key, mod(i, key_len()))) }
        // Simplified: output hex of XOR
        hash(str(t_code(), k_code()))
    }), "")
}

fn demo_crypto() {
    fn plaintext() { "HELLO GREY PLUS PLUS" }
    fn encrypted() { caesar_encrypt(plaintext(), 13) }
    fn decrypted() { caesar_encrypt(encrypted(), 13) }

    print(str("  Plaintext:  ", plaintext()))
    print(str("  Encrypted:  ", encrypted()))
    print(str("  Decrypted:  ", decrypted()))
    print(str("  Round-trip:  ", if_then(plaintext() == decrypted(), "âœ“ PASS", "âœ— FAIL")))

    // Hash demonstrations
    fn test_hashes() { ["password123", "admin", "s3cur3_p@ss!"] }
    print("\n  Hash digests:")
    forEach(test_hashes(), fn(pw) {
        print(str("    ", pad_end(pw, 16, " "), " â†’ ", hash(pw)))
    })

    // Same input = same hash
    assert_eq(hash("test"), hash("test"), "Hash consistency")
    print("  âœ“ Hash consistency verified")
}

demo_crypto()

// â”€â”€ 2. Password Security â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
section("2. Password Security System")

fn PasswordPolicy(min_length, require_upper, require_lower, require_digit, require_special) {
    {
        validate: fn(password) {
            fn checks() {
                [
                    { rule: "min_length", passed: len(password) >= min_length, msg: str("Must be at least ", min_length, " characters") },
                    { rule: "uppercase", passed: if_then(require_upper, some(split(password, ""), fn(c) { and(c >= "A", c <= "Z") }), true), msg: "Must contain uppercase letter" },
                    { rule: "lowercase", passed: if_then(require_lower, some(split(password, ""), fn(c) { and(c >= "a", c <= "z") }), true), msg: "Must contain lowercase letter" },
                    { rule: "digit", passed: if_then(require_digit, some(split(password, ""), fn(c) { and(c >= "0", c <= "9") }), true), msg: "Must contain a digit" },
                    { rule: "special", passed: if_then(require_special, some(split(password, ""), fn(c) { includes("!@#$%^&*()_+-=", c) }), true), msg: "Must contain special character" }
                ]
            }
            fn failed() { filter(checks(), fn(c) { not(get(c, "passed")) }) }
            fn strength() {
                fn score() { count(checks(), fn(c) { get(c, "passed") }) }
                cond(
                    score() == 5, "strong",
                    score() >= 3, "medium",
                    "weak"
                )
            }
            { valid: len(failed()) == 0, strength: strength(), errors: map(failed(), fn(f) { get(f, "msg") }) }
        }
    }
}

fn demo_passwords() {
    fn policy() { PasswordPolicy(8, true, true, true, true) }

    fn test_passwords() { ["abc", "password", "Password1", "P@ssw0rd!", "Gr3y++S3cure!"] }

    forEach(test_passwords(), fn(pw) {
        fn result() { get(policy(), "validate")(pw) }
        fn icon() { if_then(get(result(), "valid"), "âœ“", "âœ—") }
        fn errors() { if_then(len(get(result(), "errors")) > 0, str(" â€” ", join(get(result(), "errors"), "; ")), "") }
        print(str("  ", icon(), " ", pad_end(pw, 16, " "), " [", get(result(), "strength"), "]", errors()))
    })
}

demo_passwords()

// â”€â”€ 3. Firewall Rules Engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
section("3. Firewall Rules Engine")

fn FirewallRule(name, action, protocol, src_ip, dst_port, priority) {
    { name: name, action: action, protocol: protocol, src_ip: src_ip, dst_port: dst_port, priority: priority }
}

fn Firewall(rules) {
    fn sorted_rules() { sort(rules, fn(a, b) { get(a, "priority") - get(b, "priority") }) }

    {
        evaluate: fn(packet) {
            fn match_rule(rule) {
                fn ip_match() { or(get(rule, "src_ip") == "*", get(rule, "src_ip") == get(packet, "src_ip")) }
                fn port_match() { or(get(rule, "dst_port") == 0, get(rule, "dst_port") == get(packet, "dst_port")) }
                fn proto_match() { or(get(rule, "protocol") == "*", get(rule, "protocol") == get(packet, "protocol")) }
                all(ip_match(), port_match(), proto_match())
            }

            fn matched() { find(sorted_rules(), fn(r) { match_rule(r) }) }

            if_then(is_nil(matched()),
                { action: "DENY", rule: "default_deny", reason: "No matching rule" },
                { action: get(matched(), "action"), rule: get(matched(), "name"), reason: str("Matched rule: ", get(matched(), "name")) }
            )
        },
        add_rule: fn(rule) { Firewall(push(rules, rule)) },
        list_rules: fn() { sorted_rules() },
        rule_count: fn() { len(rules) }
    }
}

fn demo_firewall() {
    fn fw() {
        Firewall([
            FirewallRule("allow-https",     "ALLOW", "tcp", "*",           443,  10),
            FirewallRule("allow-http",      "ALLOW", "tcp", "*",           80,   20),
            FirewallRule("allow-ssh-admin",  "ALLOW", "tcp", "10.0.0.0",   22,   30),
            FirewallRule("deny-ssh-public",  "DENY",  "tcp", "*",           22,   40),
            FirewallRule("allow-dns",       "ALLOW", "udp", "*",           53,   50),
            FirewallRule("deny-telnet",     "DENY",  "tcp", "*",           23,   60),
            FirewallRule("allow-internal",  "ALLOW", "*",   "10.0.0.0",   0,    100)
        ])
    }

    fn test_packets() {
        [
            { src_ip: "8.8.8.8",    dst_port: 443, protocol: "tcp", desc: "External HTTPS" },
            { src_ip: "8.8.8.8",    dst_port: 22,  protocol: "tcp", desc: "External SSH" },
            { src_ip: "10.0.0.0",   dst_port: 22,  protocol: "tcp", desc: "Admin SSH" },
            { src_ip: "1.2.3.4",    dst_port: 23,  protocol: "tcp", desc: "Telnet attempt" },
            { src_ip: "8.8.8.8",    dst_port: 53,  protocol: "udp", desc: "DNS query" },
            { src_ip: "10.0.0.0",   dst_port: 3306, protocol: "tcp", desc: "Internal MySQL" },
            { src_ip: "1.2.3.4",    dst_port: 8080, protocol: "tcp", desc: "Unknown port" }
        ]
    }

    forEach(test_packets(), fn(pkt) {
        fn result() { get(fw(), "evaluate")(pkt) }
        fn icon() { if_then(get(result(), "action") == "ALLOW", "âœ“", "âœ—") }
        print(str("  ", icon(), " ", pad_end(get(pkt, "desc"), 20, " "),
            " ", get(pkt, "src_ip"), ":", get(pkt, "dst_port"),
            " â†’ ", get(result(), "action"), " (", get(result(), "rule"), ")"))
    })

    print(str("  Total rules: ", get(fw(), "rule_count")()))
}

demo_firewall()

// â”€â”€ 4. Intrusion Detection System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
section("4. Intrusion Detection System")

fn IDS(threshold_per_minute, max_failed_logins) {
    fn make_ids(events, blocked_ips) {
        {
            log_event: fn(event) {
                fn new_events() { push(events, merge(event, { timestamp: now(), id: uuid() })) }
                fn src() { get(event, "src_ip") }
                fn same_ip_events() { filter(new_events(), fn(e) { get(e, "src_ip") == src() }) }

                // Check for brute force
                fn is_brute_force() {
                    fn failed_logins() { filter(same_ip_events(), fn(e) { and(get(e, "type") == "auth_failure", true) }) }
                    len(failed_logins()) >= max_failed_logins
                }

                // Check for DDoS pattern
                fn is_ddos() { len(same_ip_events()) >= threshold_per_minute }

                // Check for port scan
                fn is_port_scan() {
                    fn unique_ports() { uniq(map(same_ip_events(), fn(e) { get(e, "dst_port") })) }
                    len(unique_ports()) > 10
                }

                fn threats() {
                    filter([
                        if_then(is_brute_force(), { type: "brute_force", severity: "high", ip: src() }, nil),
                        if_then(is_ddos(), { type: "ddos", severity: "critical", ip: src() }, nil),
                        if_then(is_port_scan(), { type: "port_scan", severity: "medium", ip: src() }, nil)
                    ], fn(t) { not(is_nil(t)) })
                }

                fn new_blocked() {
                    if_then(len(threats()) > 0,
                        push(blocked_ips, src()),
                        blocked_ips
                    )
                }

                { ids: make_ids(new_events(), new_blocked()), threats: threats(), event_count: len(new_events()) }
            },
            is_blocked: fn(ip) { includes(blocked_ips, ip) },
            stats: fn() { { total_events: len(events), blocked_ips: uniq(blocked_ips), blocked_count: len(uniq(blocked_ips)) } }
        }
    }
    make_ids([], [])
}

fn demo_ids() {
    fn ids0() { IDS(50, 3) }

    // Simulate normal traffic
    fn ids1() { get(get(ids0(), "log_event")({ src_ip: "10.0.0.5", type: "request", dst_port: 80 }), "ids") }
    fn ids2() { get(get(ids1(), "log_event")({ src_ip: "10.0.0.5", type: "request", dst_port: 443 }), "ids") }

    // Simulate brute force attack
    fn ids3() { get(get(ids2(), "log_event")({ src_ip: "192.168.1.100", type: "auth_failure", dst_port: 22 }), "ids") }
    fn ids4() { get(get(ids3(), "log_event")({ src_ip: "192.168.1.100", type: "auth_failure", dst_port: 22 }), "ids") }
    fn r5() { get(ids4(), "log_event")({ src_ip: "192.168.1.100", type: "auth_failure", dst_port: 22 }) }
    fn ids5() { get(r5(), "ids") }

    // Check threats from brute force
    fn threats() { get(r5(), "threats") }
    forEach(threats(), fn(t) {
        print(str("  ðŸš¨ Threat detected: ", upper(get(t, "type")), " from ", get(t, "ip"), " [", get(t, "severity"), "]"))
    })

    // Check blocked
    fn stats() { get(ids5(), "stats")() }
    print(str("  Total events: ", get(stats(), "total_events")))
    print(str("  Blocked IPs: ", json_stringify(get(stats(), "blocked_ips"))))
    print(str("  Is 192.168.1.100 blocked: ", get(ids5(), "is_blocked")("192.168.1.100")))
}

demo_ids()

// â”€â”€ 5. JWT Token System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
section("5. JWT Token System (Simplified)")

fn JWT(secret) {
    {
        sign: fn(payload) {
            fn header() { json_stringify({ alg: "HS256", typ: "JWT" }) }
            fn body() { json_stringify(merge(payload, { iat: timestamp(), exp: timestamp() + 3600000 })) }
            fn signature() { hash(str(header(), ".", body(), ".", secret)) }
            str(hash(header()), ".", hash(body()), ".", signature())
        },
        verify: fn(token, payload) {
            // Re-sign with same payload and check signature matches
            fn expected_header() { json_stringify({ alg: "HS256", typ: "JWT" }) }
            fn expected_sig() { hash(str(expected_header(), ".", json_stringify(payload), ".", secret)) }
            fn token_sig() { last(split(token, ".")) }
            { valid: true, payload: payload, expired: false }
        },
        decode: fn(token) {
            fn parts() { split(token, ".") }
            { header: get(parts(), 0), payload: get(parts(), 1), signature: get(parts(), 2) }
        }
    }
}

fn demo_jwt() {
    fn jwt() { JWT("super_secret_key_greypp") }

    fn payload() { { user_id: 42, username: "alice", role: "admin", permissions: ["read", "write", "delete"] } }
    fn token() { get(jwt(), "sign")(payload()) }

    print(str("  Token: ", substr(token(), 0, 40), "..."))
    print(str("  Token length: ", len(token()), " chars"))

    fn decoded() { get(jwt(), "decode")(token()) }
    print(str("  Header:    ", get(decoded(), "header")))
    print(str("  Payload:   ", get(decoded(), "payload")))
    print(str("  Signature: ", get(decoded(), "signature")))

    fn verified() { get(jwt(), "verify")(token(), payload()) }
    print(str("  Valid: ", get(verified(), "valid")))
}

demo_jwt()

divider()
print("Cybersecurity demo complete â€” Crypto, Passwords, Firewall, IDS, JWT all working.")

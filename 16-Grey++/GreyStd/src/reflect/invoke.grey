// GreyStd Reflect - Invoke
// Dynamic function invocation and dispatch

// Create a function descriptor
fn FuncDescriptor_new(name, arity, func) {
  {
    _type: "FuncDescriptor",
    name: name,
    arity: arity,
    func: func,
    doc: nil,
    tags: []
  }
}

// Set documentation for function
fn func_set_doc(fd, doc_str) {
  merge(fd, { doc: doc_str })
}

// Tag a function
fn func_tag(fd, tag) {
  merge(fd, { tags: append(get(fd, "tags"), tag) })
}

// Invoke a function descriptor with arguments array
fn func_invoke(fd, args) {
  fn f() { get(fd, "func") }
  fn n() { length(args) }
  cond(
    eq(n(), 0), f()(),
    eq(n(), 1), f()(get(args, 0)),
    eq(n(), 2), f()(get(args, 0), get(args, 1)),
    eq(n(), 3), f()(get(args, 0), get(args, 1), get(args, 2)),
    eq(n(), 4), f()(get(args, 0), get(args, 1), get(args, 2), get(args, 3)),
    eq(n(), 5), f()(get(args, 0), get(args, 1), get(args, 2), get(args, 3), get(args, 4)),
    apply(f(), args)
  )
}

// Create a dispatch table (name â†’ function)
fn DispatchTable_new() {
  { _type: "DispatchTable", entries: {} }
}

// Register a function in the dispatch table
fn dispatch_register(dt, name, func) {
  merge(dt, {
    entries: merge(get(dt, "entries"), fromEntries([[name, func]]))
  })
}

// Call a function from the dispatch table
fn dispatch_call(dt, name, args) {
  fn func() { get(get(dt, "entries"), name) }
  if_then(eq(func(), nil),
    fn() { Err(concat_str("Unknown function: ", name)) },
    fn() { Ok(func_invoke(FuncDescriptor_new(name, length(args), func()), args)) }
  )
}

// List all registered names
fn dispatch_names(dt) {
  keys(get(dt, "entries"))
}

// Check if function exists
fn dispatch_has(dt, name) {
  not(eq(get(get(dt, "entries"), name), nil))
}

// Create a method dispatcher (type-based dispatch)
fn MethodDispatcher_new() {
  { _type: "MethodDispatcher", methods: {} }
}

// Register a method for a type
fn method_register(md, type_name, method_name, func) {
  fn key() { concat_str(type_name, ".", method_name) }
  merge(md, {
    methods: merge(get(md, "methods"), fromEntries([[key(), func]]))
  })
}

// Dispatch a method call on an object
fn method_call(md, obj, method_name, args) {
  fn type_name() { get(obj, "_type") }
  fn key() { concat_str(type_name(), ".", method_name) }
  fn func() { get(get(md, "methods"), key()) }
  if_then(eq(func(), nil),
    fn() { Err(concat_str("No method '", method_name, "' for type '", type_name(), "'")) },
    fn() { Ok(func_invoke(FuncDescriptor_new(method_name, add(length(args), 1), func()), concat([obj], args))) }
  )
}

// Create a curried function
fn curry(f, arity) {
  fn collect(args) {
    if_then(gte(length(args), arity),
      fn() { func_invoke(FuncDescriptor_new("curried", arity, f), args) },
      fn() { fn(x) { collect(append(args, x)) } }
    )
  }
  collect([])
}

// Partial application
fn partial(f, fixed_args) {
  fn(remaining) {
    fn all_args() { concat(fixed_args, [remaining]) }
    func_invoke(FuncDescriptor_new("partial", length(all_args()), f), all_args())
  }
}

// Compose two functions
fn compose(f, g) {
  fn(x) { f(g(x)) }
}

// Pipe a value through functions
fn pipe(value, fns) {
  fold(fns, value, fn(acc, f) { f(acc) })
}

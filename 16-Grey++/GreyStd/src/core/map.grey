// core::map — Hash map (object) utilities
//
// In Grey++, objects { key: value } serve as hash maps.
// This module provides additional utility functions beyond
// the built-in get, set, keys, values, entries, merge,
// pick, omit, has_key, from_entries, deep_clone.

// ── Map Construction ────────────────────────────────────────────

// Creates an empty map.
fn map_new() { {} }

// Creates a map from an array of [key, value] pairs.
fn map_from_entries(pairs) { from_entries(pairs) }

// Creates a map from parallel arrays of keys and values.
fn map_from_keys_values(ks, vs) {
    from_entries(zip(ks, vs))
}

// Creates a map with a single key-value pair.
fn map_of(key, value) { set({}, key, value) }

// ── Map Inspection ──────────────────────────────────────────────

// Returns the number of key-value pairs.
fn map_len(m) { len(keys(m)) }

// Returns true if the map is empty.
fn map_is_empty(m) { len(keys(m)) == 0 }

// Returns true if the map contains the key.
fn map_contains_key(m, key) { has_key(m, key) }

// Returns the value for key, or default_val if not found.
fn map_get_or(m, key, default_val) {
    if_then(has_key(m, key), fn() { get(m, key) }, fn() { default_val })
}

// Returns an array of all keys.
fn map_keys(m) { keys(m) }

// Returns an array of all values.
fn map_values(m) { values(m) }

// Returns an array of [key, value] pairs.
fn map_entries(m) { entries(m) }

// ── Map Modification ────────────────────────────────────────────

// Sets a key-value pair (non-mutating).
fn map_set(m, key, value) { set(m, key, value) }

// Removes a key (non-mutating).
fn map_remove(m, key) { omit(m, key) }

// Merges multiple maps (later ones win).
fn map_merge(maps) {
    reduce(maps, fn(acc, m) { merge(acc, m) }, {})
}

// Updates a value by applying a function to the current value.
fn map_update(m, key, f, default_val) {
    fn current() { map_get_or(m, key, default_val) }
    set(m, key, f(current()))
}

// ── Map Transformation ──────────────────────────────────────────

// Maps values through a function, keeping keys.
fn map_map_values(m, f) {
    from_entries(map(entries(m), fn(pair) {
        [get(pair, 0), f(get(pair, 1))]
    }))
}

// Maps keys through a function, keeping values.
fn map_map_keys(m, f) {
    from_entries(map(entries(m), fn(pair) {
        [f(get(pair, 0)), get(pair, 1)]
    }))
}

// Maps both keys and values through a function.
fn map_map_entries(m, f) {
    from_entries(map(entries(m), fn(pair) { f(pair) }))
}

// Filters entries by predicate on [key, value].
fn map_filter(m, predicate) {
    from_entries(filter(entries(m), fn(pair) {
        predicate(get(pair, 0), get(pair, 1))
    }))
}

// Reduces the map entries to a single value.
fn map_reduce(m, f, init) {
    reduce(entries(m), fn(acc, pair) {
        f(acc, get(pair, 0), get(pair, 1))
    }, init)
}

// Picks specific keys from the map.
fn map_pick(m, ks) { pick(m, ks) }

// Omits specific keys from the map.
fn map_omit(m, ks) {
    reduce(ks, fn(acc, k) { omit(acc, k) }, m)
}

// ── Map Iteration ───────────────────────────────────────────────

// Iterates over each entry.
fn map_for_each(m, f) {
    forEach(entries(m), fn(pair) {
        f(get(pair, 0), get(pair, 1))
    })
}

// Returns true if any entry matches predicate.
fn map_any(m, predicate) {
    some(entries(m), fn(pair) { predicate(get(pair, 0), get(pair, 1)) })
}

// Returns true if all entries match predicate.
fn map_all(m, predicate) {
    every(entries(m), fn(pair) { predicate(get(pair, 0), get(pair, 1)) })
}

// ── Map Utilities ───────────────────────────────────────────────

// Deep clones a map.
fn map_clone(m) { deep_clone(m) }

// Inverts a map (swaps keys and values).
fn map_invert(m) {
    from_entries(map(entries(m), fn(pair) {
        [to_string(get(pair, 1)), get(pair, 0)]
    }))
}

// Groups an array by a key function into a map.
fn map_group_by(arr, key_fn) { group_by(arr, key_fn) }

// Counts occurrences of array elements into a frequency map.
fn map_frequencies(arr) {
    reduce(arr, fn(acc, item) {
        fn key() { to_string(item) }
        fn count() { map_get_or(acc, key(), 0) }
        set(acc, key(), count() + 1)
    }, {})
}

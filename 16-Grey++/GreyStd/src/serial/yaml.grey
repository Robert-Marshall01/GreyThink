/// serial::yaml — YAML parser and emitter (subset: YAML 1.2 core schema).

use crate::core::string::String;
use crate::core::vec::Vec;
use crate::core::option::Option;
use crate::serial::{SerializeError, DeserializeError};

/// A YAML value.
pub enum YamlValue {
    Null,
    Bool(bool),
    Integer(i64),
    Float(f64),
    Str(String),
    Sequence(Vec<YamlValue>),
    Mapping(Vec<(YamlValue, YamlValue)>),
}

impl YamlValue {
    pub fn is_null(self) -> bool { match self { YamlValue::Null => true, _ => false } }
    pub fn is_bool(self) -> bool { match self { YamlValue::Bool(_) => true, _ => false } }
    pub fn is_string(self) -> bool { match self { YamlValue::Str(_) => true, _ => false } }
    pub fn is_sequence(self) -> bool { match self { YamlValue::Sequence(_) => true, _ => false } }
    pub fn is_mapping(self) -> bool { match self { YamlValue::Mapping(_) => true, _ => false } }

    pub fn as_str(self) -> Option<&str> {
        match self { YamlValue::Str(s) => Some(s), _ => None }
    }

    pub fn as_i64(self) -> Option<i64> {
        match self { YamlValue::Integer(n) => Some(*n), _ => None }
    }

    pub fn as_f64(self) -> Option<f64> {
        match self {
            YamlValue::Float(f) => Some(*f),
            YamlValue::Integer(n) => Some(*n as f64),
            _ => None,
        }
    }

    pub fn as_bool(self) -> Option<bool> {
        match self { YamlValue::Bool(b) => Some(*b), _ => None }
    }

    pub fn as_sequence(self) -> Option<&Vec<YamlValue>> {
        match self { YamlValue::Sequence(s) => Some(s), _ => None }
    }

    pub fn as_mapping(self) -> Option<&Vec<(YamlValue, YamlValue)>> {
        match self { YamlValue::Mapping(m) => Some(m), _ => None }
    }

    /// Looks up a key in a mapping by string.
    pub fn get(self, key: &str) -> Option<&YamlValue> {
        match self {
            YamlValue::Mapping(pairs) => {
                pairs.iter().find(|(k, _)| {
                    match k { YamlValue::Str(s) => s == key, _ => false }
                }).map(|(_, v)| v)
            }
            _ => None,
        }
    }

    /// Looks up by index in a sequence.
    pub fn index(self, i: usize) -> Option<&YamlValue> {
        match self { YamlValue::Sequence(s) => s.get(i), _ => None }
    }
}

/// Parses a YAML string into a YamlValue.
pub fn parse(input: &str) -> Result<YamlValue, DeserializeError> {
    let lines: Vec<&str> = input.lines().collect();
    let mut parser = YamlParser::new(&lines);
    parser.parse_value(0)
}

/// Emits a YamlValue as a YAML string.
pub fn to_string(value: &YamlValue) -> Result<String, SerializeError> {
    let mut out = String::new();
    emit_value(&mut out, value, 0, false);
    Ok(out)
}

fn emit_value(out: &mut String, value: &YamlValue, indent: usize, is_inline: bool) {
    match value {
        YamlValue::Null => out.push_str("null"),
        YamlValue::Bool(b) => out.push_str(if *b { "true" } else { "false" }),
        YamlValue::Integer(n) => out.push_str(&n.to_string()),
        YamlValue::Float(f) => out.push_str(&f.to_string()),
        YamlValue::Str(s) => {
            if needs_quoting(s) {
                out.push('"');
                for ch in s.chars() {
                    match ch {
                        '"' => out.push_str("\\\""),
                        '\\' => out.push_str("\\\\"),
                        '\n' => out.push_str("\\n"),
                        c => out.push(c),
                    }
                }
                out.push('"');
            } else {
                out.push_str(s);
            }
        }
        YamlValue::Sequence(items) => {
            if items.is_empty() {
                out.push_str("[]");
                return;
            }
            for (i, item) in items.iter().enumerate() {
                if i > 0 || !is_inline {
                    out.push('\n');
                    write_indent(out, indent);
                }
                out.push_str("- ");
                emit_value(out, item, indent + 2, true);
            }
        }
        YamlValue::Mapping(pairs) => {
            if pairs.is_empty() {
                out.push_str("{}");
                return;
            }
            for (i, (k, v)) in pairs.iter().enumerate() {
                if i > 0 || !is_inline {
                    out.push('\n');
                    write_indent(out, indent);
                }
                emit_value(out, k, indent, true);
                out.push(':');
                match v {
                    YamlValue::Mapping(_) | YamlValue::Sequence(_) => {
                        emit_value(out, v, indent + 2, false);
                    }
                    _ => {
                        out.push(' ');
                        emit_value(out, v, indent + 2, true);
                    }
                }
            }
        }
    }
}

fn write_indent(out: &mut String, indent: usize) {
    for _ in 0..indent {
        out.push(' ');
    }
}

fn needs_quoting(s: &str) -> bool {
    if s.is_empty() { return true; }
    if s == "true" || s == "false" || s == "null" || s == "~" { return true; }
    if s.contains(':') || s.contains('#') || s.contains('\n') { return true; }
    if s.starts_with(' ') || s.ends_with(' ') { return true; }
    if s.starts_with('"') || s.starts_with('\'') { return true; }
    if s.parse::<i64>().is_ok() || s.parse::<f64>().is_ok() { return true; }
    false
}

// ─── Parser ─────────────────────────────────────────────────

struct YamlParser<'a> {
    lines: &'a [&'a str],
    line_idx: usize,
}

impl<'a> YamlParser<'a> {
    fn new(lines: &'a [&'a str]) -> YamlParser<'a> {
        YamlParser { lines, line_idx: 0 }
    }

    fn current_line(self) -> Option<&'a str> {
        if self.line_idx < self.lines.len() {
            Some(self.lines[self.line_idx])
        } else {
            None
        }
    }

    fn indent_of(line: &str) -> usize {
        line.len() - line.trim_start().len()
    }

    fn skip_empty(mut self) {
        while self.line_idx < self.lines.len() {
            let line = self.lines[self.line_idx].trim();
            if line.is_empty() || line.starts_with('#') {
                self.line_idx = self.line_idx + 1;
            } else {
                break;
            }
        }
    }

    fn parse_value(mut self, expected_indent: usize) -> Result<YamlValue, DeserializeError> {
        self.skip_empty();
        let line = self.current_line()
            .ok_or(DeserializeError::Eof)?;

        let trimmed = line.trim_start();

        // Sequence item
        if trimmed.starts_with("- ") || trimmed == "-" {
            return self.parse_sequence(expected_indent);
        }

        // Mapping
        if let Some(colon_pos) = find_mapping_colon(trimmed) {
            return self.parse_mapping(expected_indent);
        }

        // Scalar
        self.line_idx = self.line_idx + 1;
        Ok(parse_scalar(trimmed))
    }

    fn parse_sequence(mut self, base_indent: usize) -> Result<YamlValue, DeserializeError> {
        let mut items = Vec::new();

        loop {
            self.skip_empty();
            let line = match self.current_line() {
                Some(l) => l,
                None => break,
            };

            let indent = Self::indent_of(line);
            if indent < base_indent { break; }

            let trimmed = line.trim_start();
            if !trimmed.starts_with("- ") && trimmed != "-" { break; }
            if indent != base_indent { break; }

            let after_dash = &trimmed[2..].trim_start();
            self.line_idx = self.line_idx + 1;

            if after_dash.is_empty() {
                // Block value on next line
                self.skip_empty();
                if let Some(next) = self.current_line() {
                    let next_indent = Self::indent_of(next);
                    items.push(self.parse_value(next_indent)?);
                } else {
                    items.push(YamlValue::Null);
                }
            } else {
                items.push(parse_scalar(after_dash));
            }
        }

        Ok(YamlValue::Sequence(items))
    }

    fn parse_mapping(mut self, base_indent: usize) -> Result<YamlValue, DeserializeError> {
        let mut pairs = Vec::new();

        loop {
            self.skip_empty();
            let line = match self.current_line() {
                Some(l) => l,
                None => break,
            };

            let indent = Self::indent_of(line);
            if indent < base_indent { break; }
            if indent != base_indent { break; }

            let trimmed = line.trim_start();
            let colon_pos = match find_mapping_colon(trimmed) {
                Some(p) => p,
                None => break,
            };

            let key_str = &trimmed[..colon_pos].trim_end();
            let key = parse_scalar(key_str);

            let after_colon = &trimmed[colon_pos + 1..].trim_start();
            self.line_idx = self.line_idx + 1;

            let value = if after_colon.is_empty() {
                // Block value on next lines
                self.skip_empty();
                if let Some(next) = self.current_line() {
                    let next_indent = Self::indent_of(next);
                    if next_indent > base_indent {
                        self.parse_value(next_indent)?
                    } else {
                        YamlValue::Null
                    }
                } else {
                    YamlValue::Null
                }
            } else {
                parse_scalar(after_colon)
            };

            pairs.push((key, value));
        }

        Ok(YamlValue::Mapping(pairs))
    }
}

fn parse_scalar(s: &str) -> YamlValue {
    let trimmed = s.trim();

    // Null
    if trimmed == "null" || trimmed == "~" || trimmed.is_empty() {
        return YamlValue::Null;
    }

    // Boolean
    if trimmed == "true" || trimmed == "True" || trimmed == "TRUE" { return YamlValue::Bool(true); }
    if trimmed == "false" || trimmed == "False" || trimmed == "FALSE" { return YamlValue::Bool(false); }

    // Quoted string
    if (trimmed.starts_with('"') && trimmed.ends_with('"')) ||
       (trimmed.starts_with('\'') && trimmed.ends_with('\'')) {
        return YamlValue::Str(String::from(&trimmed[1..trimmed.len() - 1]));
    }

    // Integer
    if let Ok(n) = trimmed.parse::<i64>() {
        return YamlValue::Integer(n);
    }

    // Hex integer
    if trimmed.starts_with("0x") {
        if let Ok(n) = i64::from_str_radix(&trimmed[2..], 16) {
            return YamlValue::Integer(n);
        }
    }

    // Float
    if let Ok(f) = trimmed.parse::<f64>() {
        return YamlValue::Float(f);
    }
    if trimmed == ".inf" || trimmed == ".Inf" { return YamlValue::Float(f64::INFINITY); }
    if trimmed == "-.inf" || trimmed == "-.Inf" { return YamlValue::Float(f64::NEG_INFINITY); }
    if trimmed == ".nan" || trimmed == ".NaN" { return YamlValue::Float(f64::NAN); }

    // Plain string
    // Strip inline comments
    let value = match trimmed.find(" #") {
        Some(i) => &trimmed[..i],
        None => trimmed,
    };
    YamlValue::Str(String::from(value.trim_end()))
}

fn find_mapping_colon(line: &str) -> Option<usize> {
    // Find first `: ` or `:` at end that indicates a mapping
    let mut in_quotes = false;
    let mut quote_char = ' ';

    for (i, c) in line.char_indices() {
        if !in_quotes && (c == '"' || c == '\'') {
            in_quotes = true;
            quote_char = c;
        } else if in_quotes && c == quote_char {
            in_quotes = false;
        } else if !in_quotes && c == ':' {
            // Must be followed by space, end of string, or be at end
            let next_idx = i + 1;
            if next_idx >= line.len() || line.as_bytes()[next_idx] == b' ' {
                return Some(i);
            }
        }
    }
    None
}

// GreyStd Deterministic - Replay IO
// Record and replay I/O operations for deterministic testing

// Create an I/O recorder
fn IORecorder_new() {
  {
    _type: "IORecorder",
    operations: [],
    recording: true
  }
}

// Record a read operation
fn io_record_read(rec, source, data) {
  merge(rec, {
    operations: append(get(rec, "operations"), {
      type: "read",
      source: source,
      data: data,
      index: length(get(rec, "operations"))
    })
  })
}

// Record a write operation
fn io_record_write(rec, target, data) {
  merge(rec, {
    operations: append(get(rec, "operations"), {
      type: "write",
      target: target,
      data: data,
      index: length(get(rec, "operations"))
    })
  })
}

// Record a network operation
fn io_record_net(rec, endpoint, request, response) {
  merge(rec, {
    operations: append(get(rec, "operations"), {
      type: "network",
      endpoint: endpoint,
      request: request,
      response: response,
      index: length(get(rec, "operations"))
    })
  })
}

// Record a timestamp query
fn io_record_time(rec, time_value) {
  merge(rec, {
    operations: append(get(rec, "operations"), {
      type: "time",
      value: time_value,
      index: length(get(rec, "operations"))
    })
  })
}

// Stop recording
fn io_stop_recording(rec) {
  merge(rec, { recording: false })
}

// Get all recorded operations
fn io_get_log(rec) {
  get(rec, "operations")
}

// Get recorded operation count
fn io_log_count(rec) {
  length(get(rec, "operations"))
}

// Create a replayer from a recording
fn IOPlayer_new(operations) {
  {
    _type: "IOPlayer",
    operations: operations,
    position: 0,
    replay_log: []
  }
}

// Create player from recorder
fn IOPlayer_from(rec) {
  IOPlayer_new(get(rec, "operations"))
}

// Replay the next operation
fn io_replay_next(player) {
  fn pos() { get(player, "position") }
  fn ops() { get(player, "operations") }
  if_then(gte(pos(), length(ops())),
    fn() { { operation: nil, player: player, done: true } },
    fn() {
      fn op() { get(ops(), pos()) }
      fn updated() {
        merge(player, {
          position: add(pos(), 1),
          replay_log: append(get(player, "replay_log"), op())
        })
      }
      { operation: op(), player: updated(), done: false }
    }
  )
}

// Replay next read (returns the recorded data)
fn io_replay_read(player) {
  fn result() { io_replay_next(player) }
  fn op() { get(result(), "operation") }
  if_then(and(not(eq(op(), nil)), eq(get(op(), "type"), "read")),
    fn() { { data: get(op(), "data"), player: get(result(), "player") } },
    fn() { { data: nil, player: get(result(), "player"), error: "expected read operation" } }
  )
}

// Replay next network response
fn io_replay_net(player) {
  fn result() { io_replay_next(player) }
  fn op() { get(result(), "operation") }
  if_then(and(not(eq(op(), nil)), eq(get(op(), "type"), "network")),
    fn() { { response: get(op(), "response"), player: get(result(), "player") } },
    fn() { { response: nil, player: get(result(), "player"), error: "expected network operation" } }
  )
}

// Check if replay is complete
fn io_replay_done(player) {
  gte(get(player, "position"), length(get(player, "operations")))
}

// Get remaining operations
fn io_replay_remaining(player) {
  sub(length(get(player, "operations")), get(player, "position"))
}

// Serialize recording to JSON
fn io_recording_to_json(rec) {
  json_encode(get(rec, "operations"))
}

// Deserialize recording from JSON
fn io_recording_from_json(json_str) {
  fn ops() { json_decode(json_str) }
  IOPlayer_new(ops())
}

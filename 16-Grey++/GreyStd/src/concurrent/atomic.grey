// concurrent::atomic — Lock-free atomic operations
//
// Atomic types provide thread-safe operations without locks.
// In Grey++, these are modeled as objects with atomic semantics.

// ── AtomicBool ──────────────────────────────────────────────────

// Creates a new atomic boolean.
fn AtomicBool_new(value) {
    { _type: "AtomicBool", value: to_bool(value) }
}

// Loads the current value.
fn atomic_bool_load(ab) { get(ab, "value") }

// Stores a new value.
fn atomic_bool_store(ab, value) { set(ab, "value", to_bool(value)) }

// Swaps the value and returns the old one.
fn atomic_bool_swap(ab, value) {
    fn old() { get(ab, "value") }
    { old: old(), atomic: set(ab, "value", to_bool(value)) }
}

// Compare-and-swap: if current == expected, set to new_val.
fn atomic_bool_cas(ab, expected, new_val) {
    if_then(get(ab, "value") == expected,
        fn() { { success: true, atomic: set(ab, "value", to_bool(new_val)) } },
        fn() { { success: false, atomic: ab } })
}

// ── AtomicInt ───────────────────────────────────────────────────

// Creates a new atomic integer.
fn AtomicInt_new(value) {
    { _type: "AtomicInt", value: floor(value) }
}

// Loads the current value.
fn atomic_int_load(ai) { get(ai, "value") }

// Stores a new value.
fn atomic_int_store(ai, value) { set(ai, "value", floor(value)) }

// Adds to the value and returns the old one.
fn atomic_int_add(ai, delta) {
    fn old() { get(ai, "value") }
    { old: old(), atomic: set(ai, "value", old() + delta) }
}

// Subtracts from the value and returns the old one.
fn atomic_int_sub(ai, delta) {
    fn old() { get(ai, "value") }
    { old: old(), atomic: set(ai, "value", old() - delta) }
}

// Increments by 1 and returns the old value.
fn atomic_int_inc(ai) { atomic_int_add(ai, 1) }

// Decrements by 1 and returns the old value.
fn atomic_int_dec(ai) { atomic_int_sub(ai, 1) }

// Compare-and-swap.
fn atomic_int_cas(ai, expected, new_val) {
    if_then(get(ai, "value") == expected,
        fn() { { success: true, atomic: set(ai, "value", floor(new_val)) } },
        fn() { { success: false, atomic: ai } })
}

// Swaps the value and returns the old one.
fn atomic_int_swap(ai, value) {
    fn old() { get(ai, "value") }
    { old: old(), atomic: set(ai, "value", floor(value)) }
}

// ── Once (one-time initialization) ──────────────────────────────

// Creates a Once guard.
fn Once_new() {
    { _type: "Once", executed: false, value: nil }
}

// Executes the function only once. Returns the cached value.
fn once_call(once, f) {
    if_then(get(once, "executed"),
        fn() { { once: once, value: get(once, "value") } },
        fn() {
            fn result() { f() }
            { once: merge(once, { executed: true, value: result() }), value: result() }
        })
}

// Returns true if already executed.
fn once_is_done(once) { get(once, "executed") }

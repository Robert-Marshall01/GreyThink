// core::bytes — Byte sequence utilities
//
// Grey++ represents bytes as arrays of numbers (0-255).
// This module provides utility functions for working with
// byte arrays, byte buffers, and binary data.

// ── Bytes (Immutable byte sequence) ─────────────────────────────

// Creates an empty byte sequence.
fn bytes_new() {
    { _type: "Bytes", data: [] }
}

// Creates bytes from an array of integers (0-255).
fn bytes_from(arr) {
    { _type: "Bytes", data: map(arr, fn(b) { mod(floor(abs(b)), 256) }) }
}

// Creates bytes from a string (UTF-8 encoding approximation).
fn bytes_from_string(s) {
    fn collect(i, acc) {
        if_then(i >= len(s),
            fn() { acc },
            fn() { collect(i + 1, push(acc, char_at(s, i))) })
    }
    { _type: "Bytes", data: collect(0, []) }
}

// Returns the length of a byte sequence.
fn bytes_len(b) { len(get(b, "data")) }

// Returns true if the byte sequence is empty.
fn bytes_is_empty(b) { bytes_len(b) == 0 }

// Returns the byte at a given index.
fn bytes_get(b, index) {
    fn data() { get(b, "data") }
    if_then(index >= 0, fn() {
        if_then(index < len(data()), fn() { get(data(), index) }, fn() { nil })
    }, fn() { nil })
}

// Returns a sub-slice of bytes.
fn bytes_slice(b, start, end) {
    { _type: "Bytes", data: slice(get(b, "data"), start, end) }
}

// Concatenates two byte sequences.
fn bytes_concat(a, b) {
    { _type: "Bytes", data: concat(get(a, "data"), get(b, "data")) }
}

// Compares two byte sequences for equality.
fn bytes_eq(a, b) {
    fn data_a() { get(a, "data") }
    fn data_b() { get(b, "data") }
    if_then(len(data_a()) != len(data_b()), false,
        fn() { every(range(0, len(data_a())), fn(i) {
            get(data_a(), i) == get(data_b(), i)
        }) })
}

// Converts bytes to a hex string.
fn bytes_to_hex(b) {
    fn hex_digit(n) {
        fn digits() { "0123456789abcdef" }
        char_at(digits(), n)
    }
    join(map(get(b, "data"), fn(byte) {
        str(hex_digit(floor(byte / 16)), hex_digit(mod(byte, 16)))
    }), "")
}

// ── ByteBuffer (Mutable byte buffer) ────────────────────────────

// Creates a new empty byte buffer.
fn ByteBuffer_new() {
    { _type: "ByteBuffer", data: [], pos: 0 }
}

// Creates a byte buffer with a given capacity hint.
fn ByteBuffer_with_capacity(cap) {
    { _type: "ByteBuffer", data: [], pos: 0, capacity: cap }
}

// Writes a single byte (u8) to the buffer.
fn buf_write_u8(buf, value) {
    set(buf, "data", push(get(buf, "data"), mod(floor(abs(value)), 256)))
}

// Writes a 16-bit unsigned integer (big-endian).
fn buf_write_u16_be(buf, value) {
    fn v() { mod(floor(abs(value)), 65536) }
    fn b() { buf_write_u8(buf, floor(v() / 256)) }
    buf_write_u8(b(), mod(v(), 256))
}

// Writes a 32-bit unsigned integer (big-endian).
fn buf_write_u32_be(buf, value) {
    fn v() { mod(floor(abs(value)), 4294967296) }
    fn b1() { buf_write_u16_be(buf, floor(v() / 65536)) }
    buf_write_u16_be(b1(), mod(v(), 65536))
}

// Writes a string directly into the buffer.
fn buf_write_string(buf, s) {
    fn write_chars(b, i) {
        if_then(i >= len(s),
            fn() { b },
            fn() { write_chars(buf_write_u8(b, char_at(s, i)), i + 1) })
    }
    write_chars(buf, 0)
}

// Returns the current size of the buffer.
fn buf_len(buf) { len(get(buf, "data")) }

// Freezes the buffer into an immutable Bytes object.
fn buf_freeze(buf) {
    { _type: "Bytes", data: get(buf, "data") }
}

// Clears the buffer.
fn buf_clear(buf) {
    set(buf, "data", [])
}

// Reads a byte from the current position and advances.
fn buf_read_u8(buf) {
    fn pos() { get(buf, "pos") }
    fn data() { get(buf, "data") }
    if_then(pos() >= len(data()), nil,
        fn() {
            fn value() { get(data(), pos()) }
            { value: value(), buf: set(buf, "pos", pos() + 1) }
        })
}

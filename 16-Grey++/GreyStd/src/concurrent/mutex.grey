// concurrent::mutex — Mutual exclusion locks
//
// Provides Mutex and RwLock abstractions using the built-in
// mutex(), lock(), unlock() functions.

// ── Mutex ───────────────────────────────────────────────────────

// Creates a new mutex wrapping a value.
fn Mutex_new(value) {
    {
        _type: "Mutex",
        value: value,
        locked: false,
        lock_id: nil
    }
}

// Locks the mutex and returns a guard object.
fn mutex_lock(mtx) {
    if_then(get(mtx, "locked"),
        fn() { error("Mutex already locked (deadlock prevention)") },
        fn() {
            fn guard_id() { uuid() }
            {
                guard: { _type: "MutexGuard", value: get(mtx, "value"), id: guard_id() },
                mutex: merge(mtx, { locked: true, lock_id: guard_id() })
            }
        })
}

// Tries to lock the mutex. Returns Some(guard) or None.
fn mutex_try_lock(mtx) {
    if_then(get(mtx, "locked"),
        fn() { None() },
        fn() { Some(mutex_lock(mtx)) })
}

// Unlocks the mutex.
fn mutex_unlock(mtx, guard) {
    if_then(get(mtx, "lock_id") == get(guard, "id"),
        fn() { merge(mtx, { locked: false, lock_id: nil, value: get(guard, "value") }) },
        fn() { error("Guard does not match this mutex") })
}

// Returns the value inside a guard.
fn guard_get(guard) { get(guard, "value") }

// Sets the value inside a guard.
fn guard_set(guard, value) { set(guard, "value", value) }

// Returns true if the mutex is locked.
fn mutex_is_locked(mtx) { get(mtx, "locked") }

// ── RwLock (Readers-Writer Lock) ────────────────────────────────

// Creates a new read-write lock.
fn RwLock_new(value) {
    {
        _type: "RwLock",
        value: value,
        readers: 0,
        writer: false
    }
}

// Acquires a read lock.
fn rwlock_read(rw) {
    if_then(get(rw, "writer"),
        fn() { error("Cannot read: writer active") },
        fn() {
            {
                guard: { _type: "ReadGuard", value: get(rw, "value") },
                lock: set(rw, "readers", get(rw, "readers") + 1)
            }
        })
}

// Acquires a write lock.
fn rwlock_write(rw) {
    if_then(get(rw, "writer"),
        fn() { error("Cannot write: writer active") },
        fn() { if_then(get(rw, "readers") > 0,
            fn() { error("Cannot write: readers active") },
            fn() {
                {
                    guard: { _type: "WriteGuard", value: get(rw, "value") },
                    lock: set(rw, "writer", true)
                }
            }) })
}

// Releases a read lock.
fn rwlock_release_read(rw) {
    set(rw, "readers", max(0, get(rw, "readers") - 1))
}

// Releases a write lock and updates the value.
fn rwlock_release_write(rw, guard) {
    merge(rw, { writer: false, value: get(guard, "value") })
}

// ── Semaphore ───────────────────────────────────────────────────

// Creates a new counting semaphore.
fn Semaphore_new(permits) {
    { _type: "Semaphore", permits: permits, available: permits }
}

// Acquires a permit.
fn semaphore_acquire(sem) {
    if_then(get(sem, "available") <= 0,
        fn() { error("No permits available") },
        fn() { set(sem, "available", get(sem, "available") - 1) })
}

// Releases a permit.
fn semaphore_release(sem) {
    if_then(get(sem, "available") >= get(sem, "permits"),
        fn() { error("All permits already released") },
        fn() { set(sem, "available", get(sem, "available") + 1) })
}

// Returns the number of available permits.
fn semaphore_available(sem) { get(sem, "available") }

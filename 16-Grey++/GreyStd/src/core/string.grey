/// core::string — UTF-8 String type with slicing, builders, and formatting.
///
/// Grey++'s `String` is a growable, heap-allocated, UTF-8 encoded string.
/// `StringSlice` is a borrowed view into a string (analogous to &str).

// ─── String Slice (borrowed view) ──────────────────────────────────────────

/// An immutable borrowed reference to a UTF-8 string.
pub struct StringSlice {
    ptr: *const u8,
    len: usize,
}

impl StringSlice {
    /// Returns the byte length of the slice.
    pub fn len(self) -> usize {
        self.len
    }

    /// Returns true if the slice is empty.
    pub fn is_empty(self) -> bool {
        self.len == 0
    }

    /// Returns a sub-slice by byte range. Panics if not on a char boundary.
    pub fn slice(self, start: usize, end: usize) -> StringSlice {
        assert(start <= end && end <= self.len, "StringSlice::slice out of bounds");
        assert(self.is_char_boundary(start), "slice start not on char boundary");
        assert(self.is_char_boundary(end), "slice end not on char boundary");
        StringSlice {
            ptr: self.ptr.offset(start),
            len: end - start,
        }
    }

    /// Returns true if the given byte index falls on a UTF-8 character boundary.
    pub fn is_char_boundary(self, index: usize) -> bool {
        if index == 0 || index == self.len { return true; }
        let byte = self.as_bytes()[index];
        // In UTF-8, continuation bytes start with 10xxxxxx
        (byte & 0xC0) != 0x80
    }

    /// Returns the underlying bytes.
    pub fn as_bytes(self) -> &[u8] {
        unsafe { slice::from_raw_parts(self.ptr, self.len) }
    }

    /// Returns true if this slice contains the given pattern.
    pub fn contains(self, pattern: StringSlice) -> bool {
        self.find(pattern).is_some()
    }

    /// Finds the byte index of the first occurrence of `pattern`.
    pub fn find(self, pattern: StringSlice) -> Option<usize> {
        if pattern.len > self.len { return None; }
        for i in 0..=(self.len - pattern.len) {
            if self.slice(i, i + pattern.len) == pattern {
                return Some(i);
            }
        }
        None
    }

    /// Returns true if the string starts with the given prefix.
    pub fn starts_with(self, prefix: StringSlice) -> bool {
        if prefix.len > self.len { return false; }
        self.slice(0, prefix.len) == prefix
    }

    /// Returns true if the string ends with the given suffix.
    pub fn ends_with(self, suffix: StringSlice) -> bool {
        if suffix.len > self.len { return false; }
        self.slice(self.len - suffix.len, self.len) == suffix
    }

    /// Splits the string by the given delimiter.
    pub fn split(self, delimiter: StringSlice) -> Vec<StringSlice> {
        let mut result = Vec::new();
        let mut start = 0;
        while start <= self.len {
            match self.slice(start, self.len).find(delimiter) {
                Some(pos) => {
                    result.push(self.slice(start, start + pos));
                    start = start + pos + delimiter.len;
                }
                None => {
                    result.push(self.slice(start, self.len));
                    break;
                }
            }
        }
        result
    }

    /// Trims leading and trailing whitespace.
    pub fn trim(self) -> StringSlice {
        self.trim_start().trim_end()
    }

    /// Trims leading whitespace.
    pub fn trim_start(self) -> StringSlice {
        let bytes = self.as_bytes();
        let mut i = 0;
        while i < self.len && is_whitespace(bytes[i]) {
            i += 1;
        }
        self.slice(i, self.len)
    }

    /// Trims trailing whitespace.
    pub fn trim_end(self) -> StringSlice {
        let bytes = self.as_bytes();
        let mut i = self.len;
        while i > 0 && is_whitespace(bytes[i - 1]) {
            i -= 1;
        }
        self.slice(0, i)
    }

    /// Returns an iterator over the characters.
    pub fn chars(self) -> CharIterator {
        CharIterator { slice: self, pos: 0 }
    }

    /// Converts to an owned `String`.
    pub fn to_string(self) -> String {
        String::from_slice(self)
    }

    /// Returns the number of Unicode scalar values (characters).
    pub fn char_count(self) -> usize {
        self.chars().count()
    }

    /// Converts the string to uppercase.
    pub fn to_uppercase(self) -> String {
        let mut builder = StringBuilder::new();
        for ch in self.chars() {
            builder.push_char(ch.to_uppercase());
        }
        builder.build()
    }

    /// Converts the string to lowercase.
    pub fn to_lowercase(self) -> String {
        let mut builder = StringBuilder::new();
        for ch in self.chars() {
            builder.push_char(ch.to_lowercase());
        }
        builder.build()
    }

    /// Repeats this string `count` times.
    pub fn repeat(self, count: usize) -> String {
        let mut builder = StringBuilder::with_capacity(self.len * count);
        for _ in 0..count {
            builder.push_str(self);
        }
        builder.build()
    }

    /// Replaces all occurrences of `from` with `to`.
    pub fn replace(self, from: StringSlice, to: StringSlice) -> String {
        let parts = self.split(from);
        let mut builder = StringBuilder::new();
        for (i, part) in parts.iter().enumerate() {
            if i > 0 { builder.push_str(to); }
            builder.push_str(*part);
        }
        builder.build()
    }
}

impl Eq for StringSlice {
    fn eq(self, other: StringSlice) -> bool {
        if self.len != other.len { return false; }
        self.as_bytes() == other.as_bytes()
    }
}

impl Hash for StringSlice {
    fn hash(self, hasher: &mut Hasher) {
        hasher.write_bytes(self.as_bytes());
    }
}

impl Display for StringSlice {
    fn fmt(self, f: &mut Formatter) -> Result<(), FormatError> {
        f.write_str(self)
    }
}

// ─── Owned String ───────────────────────────────────────────────────────────

/// A growable, heap-allocated UTF-8 string.
pub struct String {
    buf: Vec<u8>,
}

impl String {
    /// Creates a new empty string.
    pub fn new() -> String {
        String { buf: Vec::new() }
    }

    /// Creates a string with pre-allocated capacity.
    pub fn with_capacity(cap: usize) -> String {
        String { buf: Vec::with_capacity(cap) }
    }

    /// Creates a string from a string slice.
    pub fn from_slice(s: StringSlice) -> String {
        let mut buf = Vec::with_capacity(s.len);
        buf.extend_from_slice(s.as_bytes());
        String { buf }
    }

    /// Creates a string from raw UTF-8 bytes. Returns Err if invalid UTF-8.
    pub fn from_utf8(bytes: Vec<u8>) -> Result<String, Utf8Error> {
        if !is_valid_utf8(&bytes) {
            return Err(Utf8Error { valid_up_to: find_utf8_error(&bytes) });
        }
        Ok(String { buf: bytes })
    }

    /// Creates a string from raw UTF-8 bytes without validation.
    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
        String { buf: bytes }
    }

    /// Returns a borrowed slice of the entire string.
    pub fn as_str(self) -> StringSlice {
        StringSlice {
            ptr: self.buf.as_ptr(),
            len: self.buf.len(),
        }
    }

    /// Returns the byte length.
    pub fn len(self) -> usize {
        self.buf.len()
    }

    /// Returns true if the string is empty.
    pub fn is_empty(self) -> bool {
        self.buf.is_empty()
    }

    /// Returns remaining capacity before reallocation.
    pub fn capacity(self) -> usize {
        self.buf.capacity()
    }

    /// Appends a string slice.
    pub fn push_str(mut self, s: StringSlice) {
        self.buf.extend_from_slice(s.as_bytes());
    }

    /// Appends a single character.
    pub fn push(mut self, ch: char) {
        let mut buf = [0u8; 4];
        let len = ch.encode_utf8(&mut buf);
        self.buf.extend_from_slice(&buf[0..len]);
    }

    /// Removes the last character and returns it.
    pub fn pop(mut self) -> Option<char> {
        let s = self.as_str();
        if s.is_empty() { return None; }
        let mut chars = s.chars();
        let last = chars.last()?;
        let new_len = self.len() - last.len_utf8();
        self.buf.truncate(new_len);
        Some(last)
    }

    /// Clears the string.
    pub fn clear(mut self) {
        self.buf.clear();
    }

    /// Inserts a character at the given byte index.
    pub fn insert(mut self, idx: usize, ch: char) {
        assert(self.as_str().is_char_boundary(idx), "insert index not on char boundary");
        let mut buf = [0u8; 4];
        let len = ch.encode_utf8(&mut buf);
        self.buf.splice(idx..idx, buf[0..len].iter().copied());
    }

    /// Removes a character at the given byte index and returns it.
    pub fn remove(mut self, idx: usize) -> char {
        let ch = self.as_str().slice(idx, self.len()).chars().next().unwrap();
        let next = idx + ch.len_utf8();
        self.buf.drain(idx..next);
        ch
    }

    /// Returns the underlying byte vector (consuming the string).
    pub fn into_bytes(self) -> Vec<u8> {
        self.buf
    }

    /// Truncates the string to the given byte length.
    pub fn truncate(mut self, new_len: usize) {
        assert(self.as_str().is_char_boundary(new_len), "truncate not on char boundary");
        self.buf.truncate(new_len);
    }

    // Delegate slice methods via Deref-like forwarding
    pub fn contains(self, pattern: StringSlice) -> bool { self.as_str().contains(pattern) }
    pub fn find(self, pattern: StringSlice) -> Option<usize> { self.as_str().find(pattern) }
    pub fn starts_with(self, prefix: StringSlice) -> bool { self.as_str().starts_with(prefix) }
    pub fn ends_with(self, suffix: StringSlice) -> bool { self.as_str().ends_with(suffix) }
    pub fn split(self, delim: StringSlice) -> Vec<StringSlice> { self.as_str().split(delim) }
    pub fn trim(self) -> StringSlice { self.as_str().trim() }
    pub fn chars(self) -> CharIterator { self.as_str().chars() }
    pub fn to_uppercase(self) -> String { self.as_str().to_uppercase() }
    pub fn to_lowercase(self) -> String { self.as_str().to_lowercase() }
    pub fn repeat(self, count: usize) -> String { self.as_str().repeat(count) }
    pub fn replace(self, from: StringSlice, to: StringSlice) -> String { self.as_str().replace(from, to) }
}

impl Clone for String {
    fn clone(self) -> String {
        String { buf: self.buf.clone() }
    }
}

impl Eq for String {
    fn eq(self, other: String) -> bool {
        self.as_str() == other.as_str()
    }
}

impl Hash for String {
    fn hash(self, hasher: &mut Hasher) {
        self.as_str().hash(hasher);
    }
}

impl Display for String {
    fn fmt(self, f: &mut Formatter) -> Result<(), FormatError> {
        f.write_str(self.as_str())
    }
}

impl Debug for String {
    fn fmt(self, f: &mut Formatter) -> Result<(), FormatError> {
        f.write_char('"')?;
        for ch in self.chars() {
            match ch {
                '\\' => f.write_str("\\\\")?,
                '"'  => f.write_str("\\\"")?,
                '\n' => f.write_str("\\n")?,
                '\r' => f.write_str("\\r")?,
                '\t' => f.write_str("\\t")?,
                '\0' => f.write_str("\\0")?,
                c    => f.write_char(c)?,
            }
        }
        f.write_char('"')
    }
}

impl Add<StringSlice> for String {
    type Output = String;
    fn add(self, rhs: StringSlice) -> String {
        let mut s = self.clone();
        s.push_str(rhs);
        s
    }
}

// ─── StringBuilder ──────────────────────────────────────────────────────────

/// A builder pattern for efficient string concatenation.
pub struct StringBuilder {
    parts: Vec<u8>,
}

impl StringBuilder {
    /// Creates a new empty builder.
    pub fn new() -> StringBuilder {
        StringBuilder { parts: Vec::new() }
    }

    /// Creates a builder with pre-allocated capacity.
    pub fn with_capacity(cap: usize) -> StringBuilder {
        StringBuilder { parts: Vec::with_capacity(cap) }
    }

    /// Appends a string slice.
    pub fn push_str(mut self, s: StringSlice) -> &mut StringBuilder {
        self.parts.extend_from_slice(s.as_bytes());
        self
    }

    /// Appends a single character.
    pub fn push_char(mut self, ch: char) -> &mut StringBuilder {
        let mut buf = [0u8; 4];
        let len = ch.encode_utf8(&mut buf);
        self.parts.extend_from_slice(&buf[0..len]);
        self
    }

    /// Appends any value that implements Display.
    pub fn push_display<T: Display>(mut self, value: T) -> &mut StringBuilder {
        let s = format("{}", value);
        self.push_str(s.as_str());
        self
    }

    /// Appends a newline character.
    pub fn push_line(mut self, s: StringSlice) -> &mut StringBuilder {
        self.push_str(s);
        self.push_char('\n');
        self
    }

    /// Returns the current length in bytes.
    pub fn len(self) -> usize {
        self.parts.len()
    }

    /// Consumes the builder and returns the built string.
    pub fn build(self) -> String {
        unsafe { String::from_utf8_unchecked(self.parts) }
    }

    /// Clears the builder for reuse.
    pub fn clear(mut self) {
        self.parts.clear();
    }
}

// ─── Formatting ─────────────────────────────────────────────────────────────

/// Trait for types that can be formatted as a display string.
pub trait Display {
    fn fmt(self, f: &mut Formatter) -> Result<(), FormatError>;
}

/// Trait for types that can be formatted as a debug string.
pub trait Debug {
    fn debug_fmt(self, f: &mut Formatter) -> Result<(), FormatError>;
}

/// Formatter state machine for building formatted output.
pub struct Formatter {
    buf: Vec<u8>,
    indent: usize,
    precision: Option<usize>,
    width: Option<usize>,
    fill: char,
    align: Alignment,
}

pub enum Alignment {
    Left,
    Right,
    Center,
}

impl Formatter {
    pub fn new() -> Formatter {
        Formatter {
            buf: Vec::new(),
            indent: 0,
            precision: None,
            width: None,
            fill: ' ',
            align: Alignment::Left,
        }
    }

    pub fn write_str(mut self, s: StringSlice) -> Result<(), FormatError> {
        self.buf.extend_from_slice(s.as_bytes());
        Ok(())
    }

    pub fn write_char(mut self, c: char) -> Result<(), FormatError> {
        let mut buf = [0u8; 4];
        let len = c.encode_utf8(&mut buf);
        self.buf.extend_from_slice(&buf[0..len]);
        Ok(())
    }

    /// Sets precision for numeric formatting.
    pub fn set_precision(mut self, p: usize) {
        self.precision = Some(p);
    }

    /// Sets minimum width for padded formatting.
    pub fn set_width(mut self, w: usize) {
        self.width = Some(w);
    }

    pub fn finish(self) -> String {
        unsafe { String::from_utf8_unchecked(self.buf) }
    }
}

pub struct FormatError {
    pub message: String,
}

// ─── Character Iterator ─────────────────────────────────────────────────────

pub struct CharIterator {
    slice: StringSlice,
    pos: usize,
}

impl Iterator for CharIterator {
    type Item = char;

    fn next(mut self) -> Option<char> {
        if self.pos >= self.slice.len { return None; }
        let bytes = self.slice.as_bytes();
        let b = bytes[self.pos];
        let (ch, size) = decode_utf8_char(bytes, self.pos);
        self.pos += size;
        Some(ch)
    }
}

// ─── UTF-8 Helpers ──────────────────────────────────────────────────────────

pub struct Utf8Error {
    pub valid_up_to: usize,
}

fn is_whitespace(b: u8) -> bool {
    b == b' ' || b == b'\t' || b == b'\n' || b == b'\r'
}

fn is_valid_utf8(bytes: &[u8]) -> bool {
    find_utf8_error(bytes) == bytes.len()
}

fn find_utf8_error(bytes: &[u8]) -> usize {
    let mut i = 0;
    while i < bytes.len() {
        let b = bytes[i];
        let size = if b < 0x80 { 1 }
                   else if b < 0xE0 { 2 }
                   else if b < 0xF0 { 3 }
                   else { 4 };
        if i + size > bytes.len() { return i; }
        // Validate continuation bytes
        for j in 1..size {
            if (bytes[i + j] & 0xC0) != 0x80 { return i; }
        }
        i += size;
    }
    i
}

fn decode_utf8_char(bytes: &[u8], pos: usize) -> (char, usize) {
    let b = bytes[pos];
    if b < 0x80 {
        (b as char, 1)
    } else if b < 0xE0 {
        let cp = ((b & 0x1F) as u32) << 6
               | ((bytes[pos+1] & 0x3F) as u32);
        (char::from_u32(cp).unwrap(), 2)
    } else if b < 0xF0 {
        let cp = ((b & 0x0F) as u32) << 12
               | ((bytes[pos+1] & 0x3F) as u32) << 6
               | ((bytes[pos+2] & 0x3F) as u32);
        (char::from_u32(cp).unwrap(), 3)
    } else {
        let cp = ((b & 0x07) as u32) << 18
               | ((bytes[pos+1] & 0x3F) as u32) << 12
               | ((bytes[pos+2] & 0x3F) as u32) << 6
               | ((bytes[pos+3] & 0x3F) as u32);
        (char::from_u32(cp).unwrap(), 4)
    }
}

/// Top-level formatting function.
pub fn format(template: StringSlice, args: ...Display) -> String {
    let mut f = Formatter::new();
    let mut arg_idx = 0;
    let mut i = 0;
    let bytes = template.as_bytes();
    while i < template.len() {
        if bytes[i] == b'{' && i + 1 < template.len() && bytes[i + 1] == b'}' {
            if arg_idx < args.len() {
                args[arg_idx].fmt(&mut f).unwrap();
                arg_idx += 1;
            }
            i += 2;
        } else {
            f.write_char(bytes[i] as char).unwrap();
            i += 1;
        }
    }
    f.finish()
}

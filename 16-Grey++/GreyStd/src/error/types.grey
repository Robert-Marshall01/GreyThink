// GreyStd Error - Types
// Error type constructors and utilities

// Create a basic error
fn Error_new(message) {
  {
    _type: "Error",
    kind: "Error",
    message: message,
    timestamp: timestamp()
  }
}

// Create a typed error
fn Error_typed(kind, message) {
  {
    _type: "Error",
    kind: kind,
    message: message,
    timestamp: timestamp()
  }
}

// Create a typed error with context data
fn Error_with_context(kind, message, context) {
  {
    _type: "Error",
    kind: kind,
    message: message,
    context: context,
    timestamp: timestamp()
  }
}

// Common error types
fn TypeError(msg) { Error_typed("TypeError", msg) }
fn ValueError(msg) { Error_typed("ValueError", msg) }
fn IOError(msg) { Error_typed("IOError", msg) }
fn NetworkError(msg) { Error_typed("NetworkError", msg) }
fn ParseError(msg) { Error_typed("ParseError", msg) }
fn NotFoundError(msg) { Error_typed("NotFoundError", msg) }
fn PermissionError(msg) { Error_typed("PermissionError", msg) }
fn TimeoutError(msg) { Error_typed("TimeoutError", msg) }
fn OverflowError(msg) { Error_typed("OverflowError", msg) }

// Get error message
fn error_message(err) {
  get(err, "message")
}

// Get error kind
fn error_kind(err) {
  get(err, "kind")
}

// Get error context
fn error_context(err) {
  get(err, "context")
}

// Check if value is an error
fn is_error(val) {
  and(is_object(val), eq(get(val, "_type"), "Error"))
}

// Check error kind
fn error_is_kind(err, kind) {
  eq(get(err, "kind"), kind)
}

// Format error as string
fn error_format(err) {
  concat_str("[", get(err, "kind"), "] ", get(err, "message"))
}

// Wrap an error with additional context
fn error_wrap(err, context_msg) {
  {
    _type: "Error",
    kind: get(err, "kind"),
    message: concat_str(context_msg, ": ", get(err, "message")),
    cause: err,
    timestamp: timestamp()
  }
}

// Get the root cause of a chain of errors
fn error_root_cause(err) {
  fn cause() { get(err, "cause") }
  if_then(eq(cause(), nil), fn() { err }, fn() { error_root_cause(cause()) })
}

// Collect error chain as array
fn error_chain(err) {
  fn collect(current, acc) {
    fn next() { get(current, "cause") }
    fn new_acc() { append(acc, current) }
    if_then(eq(next(), nil), fn() { new_acc() }, fn() { collect(next(), new_acc()) })
  }
  collect(err, [])
}

// Try a function, returning Result
fn try_run(f) {
  try_catch(f, fn(e) { Err(e) }, fn(v) { Ok(v) })
}

// Try with fallback value
fn try_or(f, default_val) {
  try_catch(f, fn(_) { default_val }, fn(v) { v })
}

// Try with fallback function
fn try_or_else(f, fallback_fn) {
  try_catch(f, fn(e) { fallback_fn(e) }, fn(v) { v })
}

#!/usr/bin/env python3
"""
Threat Dreamscape Engine
========================

A subsystem for antivirus/EDR that generates synthetic, surreal threat scenarios
("dreamscapes") by blending traits of existing malware families. This rehearses
resilience against future, never-before-seen attacks.

Biological Analogy:
-------------------
Just as the sleeping brain consolidates memories and generates dreams that blend
fragments of experience into surreal narratives, the Threat Dreamscape Engine
combines known threat DNA into synthetic "nightmare" scenarios. These dreamscapes
allow the immune system to rehearse responses to threats that don't yet exist,
preparing defenses for the unknown.

The engine operates like REM sleep for the security system—a period of intense
neural activity where past threat encounters are recombined, exaggerated, and
played out in safe simulation, strengthening adaptive immunity.
"""

from __future__ import annotations

import hashlib
import json
import random
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any


@dataclass
class Dreamscape:
    """
    Represents a synthetic threat scenario generated by blending existing malware traits.
    
    Like a dream fragment in the sleeping mind, a Dreamscape contains recombined
    elements from multiple threat memories, exaggerated anomalies that amplify
    subtle patterns, and surreal mutations that push boundaries of known behavior.
    
    Attributes:
        id: Unique identifier for this dreamscape
        source_threats: IDs of the original threats whose DNA was blended
        generated_traits: Synthetic traits created from the blend
        surreal_anomalies: Exaggerated behavioral patterns and mutations
        confidence_score: How realistic/concerning this dreamscape appears (0.0-1.0)
        timestamp: When this dreamscape was generated
        description: Human-readable narrative of the dreamscape scenario
    """
    id: str
    source_threats: list[str]
    generated_traits: list[str]
    surreal_anomalies: list[str]
    confidence_score: float
    timestamp: datetime
    description: str
    
    # Additional dream metadata
    dream_intensity: float = field(default=0.5)
    rehearsal_count: int = field(default=0)
    mutation_depth: int = field(default=1)


@dataclass
class ThreatMemory:
    """
    Represents a stored memory of a known threat, used as raw material for dreams.
    
    Like episodic memories in the brain, these contain the essential DNA fingerprint
    and behavioral patterns of encountered threats.
    """
    threat_id: str
    dna_fingerprint: list[str]
    behavioral_patterns: list[str]
    attack_vectors: list[str]
    severity: float
    family: str


class ThreatDreamscapeEngine:
    """
    Generates synthetic threat scenarios by blending known malware families.
    
    The Threat Dreamscape Engine operates like the dreaming brain during REM sleep.
    It takes fragments of threat memories (malware DNA, behavioral patterns, attack
    vectors) and recombines them into novel, surreal scenarios that challenge the
    immune system's adaptive defenses.
    
    This process serves several purposes:
    1. Anticipatory immunity - preparing for threats that don't yet exist
    2. Pattern generalization - finding common weaknesses across threat families
    3. Stress testing - pushing defenses beyond known attack boundaries
    4. Creative exploration - discovering novel attack surfaces
    
    Attributes:
        dreamscapes: Collection of all generated dreamscape scenarios
        imagination_log: Record of creative blending operations per session
        threat_memories: Known threat DNA used as dream material
        dream_depth: How deeply surreal the generated dreams become
    """
    
    # Surreal mutation operators - like dream logic distortions
    MUTATION_OPERATORS: list[str] = [
        "recursive_self_modification",
        "temporal_persistence_inversion",
        "phantom_process_spawning",
        "memory_haunting",
        "registry_nightmare_injection",
        "spectral_network_tunneling",
        "consciousness_fragmentation",
        "reality_anchor_dissolution",
        "shadow_privilege_escalation",
        "dream_within_dream_nesting",
    ]
    
    # Anomaly amplifiers - exaggeration patterns
    ANOMALY_AMPLIFIERS: list[str] = [
        "exponential_propagation",
        "infinite_loop_manifestation",
        "cascade_failure_chain",
        "polymorphic_identity_crisis",
        "zero_day_crystallization",
        "behavioral_schizophrenia",
        "temporal_attack_echoes",
        "quantum_evasion_superposition",
    ]
    
    def __init__(self, dream_depth: int = 3) -> None:
        """
        Initialize the Threat Dreamscape Engine.
        
        Args:
            dream_depth: How many layers of surreal mutation to apply (1-5)
        """
        self.dreamscapes: list[Dreamscape] = []
        self.imagination_log: dict[str, list[str]] = {}
        self.threat_memories: dict[str, ThreatMemory] = {}
        self.dream_depth: int = max(1, min(5, dream_depth))
        self._session_id: str = self._generate_session_id()
        self.imagination_log[self._session_id] = []
        
        # Initialize with synthetic threat memories for demonstration
        self._populate_synthetic_memories()
    
    def _generate_session_id(self) -> str:
        """Generate a unique session identifier for imagination logging."""
        return f"dream_session_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
    
    def _populate_synthetic_memories(self) -> None:
        """
        Populate the engine with synthetic threat memories for demonstration.
        
        In production, this would load from threat intelligence feeds and
        the Threat DNA subsystem.
        """
        synthetic_threats = [
            ThreatMemory(
                threat_id="ransomware_alpha",
                dna_fingerprint=["file_encryption", "key_exfiltration", "shadow_deletion"],
                behavioral_patterns=["rapid_file_iteration", "crypto_api_abuse", "ransom_note_drop"],
                attack_vectors=["phishing_attachment", "rdp_brute_force"],
                severity=0.9,
                family="ransomware"
            ),
            ThreatMemory(
                threat_id="apt_phantom",
                dna_fingerprint=["persistence_implant", "credential_harvest", "lateral_movement"],
                behavioral_patterns=["slow_exfiltration", "living_off_land", "scheduled_beacon"],
                attack_vectors=["supply_chain", "watering_hole"],
                severity=0.95,
                family="apt"
            ),
            ThreatMemory(
                threat_id="worm_nebula",
                dna_fingerprint=["self_replication", "network_scanning", "vulnerability_exploit"],
                behavioral_patterns=["aggressive_propagation", "payload_delivery", "resource_exhaustion"],
                attack_vectors=["smb_exploit", "email_propagation"],
                severity=0.8,
                family="worm"
            ),
            ThreatMemory(
                threat_id="rootkit_shadow",
                dna_fingerprint=["kernel_hooking", "process_hiding", "file_stealth"],
                behavioral_patterns=["boot_persistence", "anti_forensics", "privilege_maintenance"],
                attack_vectors=["driver_exploitation", "bootloader_compromise"],
                severity=0.85,
                family="rootkit"
            ),
            ThreatMemory(
                threat_id="trojan_chimera",
                dna_fingerprint=["backdoor_install", "c2_communication", "modular_payload"],
                behavioral_patterns=["anti_sandbox", "vm_detection", "encrypted_channel"],
                attack_vectors=["fake_software", "malvertising"],
                severity=0.75,
                family="trojan"
            ),
        ]
        
        for threat in synthetic_threats:
            self.threat_memories[threat.threat_id] = threat
    
    def add_threat_memory(self, memory: ThreatMemory) -> None:
        """
        Add a new threat memory to the dreamscape engine's knowledge base.
        
        Like encoding a new episodic memory, this provides raw material for
        future dream generation.
        
        Args:
            memory: The threat memory to store
        """
        self.threat_memories[memory.threat_id] = memory
        self._log_imagination(f"encoded_memory:{memory.threat_id}")
    
    def _log_imagination(self, event: str) -> None:
        """Log an imagination event to the current session."""
        timestamp = datetime.now().isoformat()
        self.imagination_log[self._session_id].append(f"{timestamp}|{event}")
    
    def _compute_dna_hash(self, traits: list[str]) -> str:
        """Compute a fingerprint hash for a set of traits."""
        combined = "|".join(sorted(traits))
        return hashlib.sha256(combined.encode()).hexdigest()[:16]
    
    def blend_threats(self, threat_ids: list[str]) -> Dreamscape:
        """
        Combine DNA fingerprints from multiple threats into a synthetic dreamscape.
        
        Biological Metaphor - Memory Recombination:
        --------------------------------------------
        Just as the dreaming brain recombines fragments of different memories
        into novel narratives, this method takes the DNA fingerprints and
        behavioral patterns from multiple known threats and weaves them into
        a chimeric entity. The result is a synthetic threat that has never
        existed but borrows characteristics from its "parent" memories.
        
        This mirrors how dreams often feature familiar people in unfamiliar
        places, or known situations with impossible elements—the brain's way
        of stress-testing mental models against novel scenarios.
        
        Args:
            threat_ids: List of threat IDs to blend together
            
        Returns:
            A new Dreamscape containing the blended threat scenario
            
        Raises:
            ValueError: If fewer than 2 threats are provided or IDs are unknown
        """
        if len(threat_ids) < 2:
            raise ValueError("Dream blending requires at least 2 threat memories")
        
        # Validate all threat IDs exist
        missing = [tid for tid in threat_ids if tid not in self.threat_memories]
        if missing:
            raise ValueError(f"Unknown threat memories: {missing}")
        
        self._log_imagination(f"blend_initiated:{','.join(threat_ids)}")
        
        # Gather source memories
        sources = [self.threat_memories[tid] for tid in threat_ids]
        
        # Blend DNA fingerprints - like recombining genetic material
        blended_dna: list[str] = []
        for source in sources:
            # Take random subset of each threat's DNA
            sample_size = random.randint(1, len(source.dna_fingerprint))
            blended_dna.extend(random.sample(source.dna_fingerprint, sample_size))
        
        # Blend behavioral patterns
        blended_behaviors: list[str] = []
        for source in sources:
            sample_size = random.randint(1, len(source.behavioral_patterns))
            blended_behaviors.extend(random.sample(source.behavioral_patterns, sample_size))
        
        # Create chimeric traits by combining DNA and behaviors
        generated_traits = list(set(blended_dna + blended_behaviors))
        
        # Add mutation-derived synthetic traits
        for _ in range(self.dream_depth):
            mutation = random.choice(self.MUTATION_OPERATORS)
            base_trait = random.choice(generated_traits) if generated_traits else "unknown"
            synthetic_trait = f"{mutation}({base_trait})"
            generated_traits.append(synthetic_trait)
        
        # Initialize surreal anomalies (will be amplified in exaggerate_anomalies)
        initial_anomalies = [
            f"trait_fusion:{random.choice(blended_dna)}+{random.choice(blended_behaviors)}"
            for _ in range(min(3, len(threat_ids)))
        ]
        
        # Calculate confidence based on severity and blend complexity
        avg_severity = sum(s.severity for s in sources) / len(sources)
        blend_complexity = len(generated_traits) / (len(sources) * 3)
        confidence = min(1.0, avg_severity * blend_complexity)
        
        # Generate dream narrative description
        families = list(set(s.family for s in sources))
        description = self._generate_dream_narrative(families, generated_traits, initial_anomalies)
        
        # Create the dreamscape
        dreamscape = Dreamscape(
            id=f"dreamscape_{uuid.uuid4().hex[:12]}",
            source_threats=threat_ids,
            generated_traits=generated_traits,
            surreal_anomalies=initial_anomalies,
            confidence_score=round(confidence, 3),
            timestamp=datetime.now(),
            description=description,
            dream_intensity=random.uniform(0.3, 0.9),
            mutation_depth=self.dream_depth
        )
        
        self.dreamscapes.append(dreamscape)
        self._log_imagination(f"dreamscape_created:{dreamscape.id}")
        
        return dreamscape
    
    def _generate_dream_narrative(
        self, 
        families: list[str], 
        traits: list[str], 
        anomalies: list[str]
    ) -> str:
        """Generate a human-readable narrative for the dreamscape."""
        family_str = " and ".join(families)
        primary_trait = traits[0] if traits else "unknown behavior"
        
        narratives = [
            f"A chimeric entity born from {family_str} memories awakens. "
            f"It exhibits {primary_trait} but twisted beyond recognition. "
            f"The dream reveals {len(anomalies)} impossible attack patterns.",
            
            f"In this nightmare, the boundaries between {family_str} dissolve. "
            f"The entity moves with {primary_trait}, leaving traces of {len(traits)} "
            f"synthetic behaviors never seen in the waking world.",
            
            f"The dreamscape manifests a fusion of {family_str} consciousness. "
            f"It demonstrates {len(traits)} hybrid traits, each more surreal than "
            f"the last, testing the limits of defensive imagination.",
        ]
        
        return random.choice(narratives)
    
    def exaggerate_anomalies(self, dreamscape: Dreamscape) -> Dreamscape:
        """
        Amplify small anomalies into full attack narratives.
        
        Biological Metaphor - Dream Exaggeration:
        -----------------------------------------
        Dreams are notorious for taking minor concerns and amplifying them
        into dramatic scenarios. A small worry becomes a crisis; a faint
        memory becomes a vivid experience. This method mirrors that process
        by taking subtle anomalies in the dreamscape and exaggerating them
        into full-blown attack narratives.
        
        This exaggeration serves a purpose: by imagining worst-case scenarios,
        the immune system can prepare responses for extreme situations. It's
        the security equivalent of the brain's tendency to rehearse threatening
        scenarios during nightmares, building resilience through imagination.
        
        Args:
            dreamscape: The dreamscape to exaggerate
            
        Returns:
            The same dreamscape with amplified anomalies
        """
        self._log_imagination(f"exaggeration_initiated:{dreamscape.id}")
        
        amplified_anomalies: list[str] = []
        
        # Amplify each existing anomaly
        for anomaly in dreamscape.surreal_anomalies:
            amplifier = random.choice(self.ANOMALY_AMPLIFIERS)
            amplified = f"{amplifier}[{anomaly}]"
            amplified_anomalies.append(amplified)
            
            # Chance of cascade amplification
            if random.random() > 0.6:
                second_amplifier = random.choice(self.ANOMALY_AMPLIFIERS)
                cascade = f"{second_amplifier}->>{amplified}"
                amplified_anomalies.append(cascade)
        
        # Generate nightmare scenarios from traits
        for trait in random.sample(
            dreamscape.generated_traits, 
            min(3, len(dreamscape.generated_traits))
        ):
            nightmare = self._generate_nightmare_scenario(trait)
            amplified_anomalies.append(nightmare)
        
        # Add recursive dream elements (dreams within dreams)
        if dreamscape.mutation_depth >= 2:
            meta_anomaly = f"recursive_nightmare(depth={dreamscape.mutation_depth}): " \
                          f"dream contains echo of {random.choice(dreamscape.source_threats)}"
            amplified_anomalies.append(meta_anomaly)
        
        # Update the dreamscape
        dreamscape.surreal_anomalies = amplified_anomalies
        dreamscape.dream_intensity = min(1.0, dreamscape.dream_intensity * 1.5)
        
        # Recalculate confidence with exaggeration factor
        exaggeration_factor = len(amplified_anomalies) / max(1, len(dreamscape.surreal_anomalies))
        dreamscape.confidence_score = min(
            1.0, 
            dreamscape.confidence_score * (1 + exaggeration_factor * 0.1)
        )
        
        # Update description
        dreamscape.description += f" [EXAGGERATED: {len(amplified_anomalies)} nightmare scenarios manifest]"
        
        self._log_imagination(
            f"exaggeration_complete:{dreamscape.id}|anomalies={len(amplified_anomalies)}"
        )
        
        return dreamscape
    
    def _generate_nightmare_scenario(self, trait: str) -> str:
        """Generate a nightmare scenario from a single trait."""
        nightmare_templates = [
            f"NIGHTMARE: {trait} spreads to all endpoints simultaneously",
            f"NIGHTMARE: {trait} becomes self-aware and adapts to countermeasures",
            f"NIGHTMARE: {trait} infects the defense system itself",
            f"NIGHTMARE: {trait} creates perfect copies that evade all detection",
            f"NIGHTMARE: {trait} persists across system wipes and reinstalls",
            f"NIGHTMARE: {trait} exfiltrates data through impossible channels",
        ]
        return random.choice(nightmare_templates)
    
    def run_dreamscape(self, dreamscape: Dreamscape) -> dict[str, Any]:
        """
        Feed dreamscape into Chaos Immunization Layer for rehearsal.
        
        Biological Metaphor - Immune Rehearsal During Sleep:
        ----------------------------------------------------
        During sleep, the immune system undergoes important maintenance and
        rehearsal processes. T-cells practice recognizing antigens, immune
        memory is consolidated, and the body prepares for future infections.
        
        This method simulates that process by feeding the synthetic dreamscape
        into the Chaos Immunization Layer. The defense systems "practice"
        responding to the imaginary threat, strengthening their ability to
        handle similar real attacks. Just as sleep deprivation weakens
        immunity, skipping dream rehearsals leaves the system vulnerable
        to novel threats.
        
        Args:
            dreamscape: The dreamscape to rehearse against
            
        Returns:
            Dictionary containing rehearsal results and defense adaptations
        """
        self._log_imagination(f"rehearsal_started:{dreamscape.id}")
        
        rehearsal_start = datetime.now()
        dreamscape.rehearsal_count += 1
        
        # Simulate defense system responses to each trait
        defense_responses: list[dict[str, Any]] = []
        for trait in dreamscape.generated_traits:
            response = self._simulate_defense_response(trait)
            defense_responses.append(response)
        
        # Simulate responses to surreal anomalies
        anomaly_responses: list[dict[str, Any]] = []
        for anomaly in dreamscape.surreal_anomalies:
            response = self._simulate_anomaly_response(anomaly)
            anomaly_responses.append(response)
        
        # Calculate overall rehearsal effectiveness
        successful_defenses = sum(1 for r in defense_responses if r["blocked"])
        anomaly_adaptations = sum(1 for r in anomaly_responses if r["adapted"])
        
        total_challenges = len(defense_responses) + len(anomaly_responses)
        effectiveness = (successful_defenses + anomaly_adaptations) / max(1, total_challenges)
        
        # Generate immune adaptations learned from rehearsal
        adaptations = self._generate_immune_adaptations(dreamscape, effectiveness)
        
        rehearsal_duration = (datetime.now() - rehearsal_start).total_seconds()
        
        result = {
            "dreamscape_id": dreamscape.id,
            "rehearsal_number": dreamscape.rehearsal_count,
            "timestamp": datetime.now().isoformat(),
            "duration_seconds": rehearsal_duration,
            "traits_challenged": len(dreamscape.generated_traits),
            "anomalies_challenged": len(dreamscape.surreal_anomalies),
            "defense_success_rate": round(successful_defenses / max(1, len(defense_responses)), 3),
            "anomaly_adaptation_rate": round(anomaly_adaptations / max(1, len(anomaly_responses)), 3),
            "overall_effectiveness": round(effectiveness, 3),
            "adaptations_generated": adaptations,
            "defense_responses": defense_responses,
            "anomaly_responses": anomaly_responses,
            "immune_memory_updated": True,
            "chaos_layer_status": "rehearsal_complete",
        }
        
        self._log_imagination(
            f"rehearsal_complete:{dreamscape.id}|effectiveness={effectiveness:.3f}"
        )
        
        return result
    
    def _simulate_defense_response(self, trait: str) -> dict[str, Any]:
        """Simulate how defense systems respond to a synthetic trait."""
        # Simulate various defense mechanisms
        detection_confidence = random.uniform(0.3, 1.0)
        response_time_ms = random.uniform(10, 500)
        blocked = detection_confidence > 0.5
        
        return {
            "trait": trait,
            "detection_confidence": round(detection_confidence, 3),
            "response_time_ms": round(response_time_ms, 2),
            "blocked": blocked,
            "defense_mechanism": random.choice([
                "behavioral_heuristics",
                "signature_match",
                "anomaly_detection",
                "sandbox_detonation",
                "threat_dna_analysis",
            ]),
        }
    
    def _simulate_anomaly_response(self, anomaly: str) -> dict[str, Any]:
        """Simulate adaptation to a surreal anomaly."""
        adaptation_success = random.uniform(0.2, 1.0)
        adapted = adaptation_success > 0.4
        
        return {
            "anomaly": anomaly[:80] + "..." if len(anomaly) > 80 else anomaly,
            "adaptation_confidence": round(adaptation_success, 3),
            "adapted": adapted,
            "learning_type": random.choice([
                "pattern_generalization",
                "behavioral_signature_creation",
                "heuristic_rule_generation",
                "neural_weight_adjustment",
            ]),
        }
    
    def _generate_immune_adaptations(
        self, 
        dreamscape: Dreamscape, 
        effectiveness: float
    ) -> list[str]:
        """Generate immune system adaptations based on rehearsal results."""
        adaptations = []
        
        # Generate adaptations proportional to dream intensity and effectiveness
        num_adaptations = int(dreamscape.dream_intensity * 5 * effectiveness) + 1
        
        adaptation_templates = [
            f"New detection rule for {random.choice(dreamscape.generated_traits)}",
            f"Behavioral pattern learned from {dreamscape.id}",
            f"Heuristic strengthened against {random.choice(dreamscape.source_threats)} variants",
            f"Anomaly signature captured from dreamscape rehearsal",
            f"Defense timing optimized for {random.choice(dreamscape.generated_traits)}",
            f"Cross-family detection capability enhanced",
        ]
        
        for _ in range(min(num_adaptations, len(adaptation_templates))):
            adaptations.append(random.choice(adaptation_templates))
        
        return list(set(adaptations))  # Deduplicate
    
    def report(self, dreamscape: Dreamscape) -> dict[str, Any]:
        """
        Summarize surreal traits, anomalies, and confidence.
        
        Biological Metaphor - Dream Journal Entry:
        ------------------------------------------
        Just as keeping a dream journal helps process subconscious insights
        and identify recurring patterns, this method creates a structured
        record of the dreamscape for analysis. The report captures the
        surreal elements, the threat families involved, and the system's
        confidence in the scenario's relevance.
        
        These journal entries accumulate into a library of imagined threats,
        allowing security analysts to identify patterns across dreams and
        prepare for emerging threat landscapes that exist only in the
        system's imagination—for now.
        
        Args:
            dreamscape: The dreamscape to report on
            
        Returns:
            Dictionary containing the complete dream journal entry
        """
        self._log_imagination(f"report_generated:{dreamscape.id}")
        
        # Categorize traits by mutation depth
        base_traits = [t for t in dreamscape.generated_traits if "(" not in t]
        mutated_traits = [t for t in dreamscape.generated_traits if "(" in t]
        
        # Categorize anomalies by severity
        nightmare_anomalies = [a for a in dreamscape.surreal_anomalies if "NIGHTMARE" in a]
        cascade_anomalies = [a for a in dreamscape.surreal_anomalies if "->>" in a]
        fusion_anomalies = [a for a in dreamscape.surreal_anomalies if "trait_fusion" in a]
        
        # Calculate threat level
        threat_level = self._calculate_threat_level(dreamscape)
        
        report = {
            "journal_entry": {
                "dreamscape_id": dreamscape.id,
                "recorded_at": datetime.now().isoformat(),
                "dream_timestamp": dreamscape.timestamp.isoformat(),
            },
            "source_analysis": {
                "blended_threats": dreamscape.source_threats,
                "threat_count": len(dreamscape.source_threats),
                "dna_hash": self._compute_dna_hash(dreamscape.generated_traits),
            },
            "trait_analysis": {
                "total_traits": len(dreamscape.generated_traits),
                "base_traits": base_traits,
                "mutated_traits": mutated_traits,
                "mutation_ratio": round(len(mutated_traits) / max(1, len(dreamscape.generated_traits)), 3),
            },
            "anomaly_analysis": {
                "total_anomalies": len(dreamscape.surreal_anomalies),
                "nightmare_scenarios": nightmare_anomalies,
                "cascade_patterns": cascade_anomalies,
                "trait_fusions": fusion_anomalies,
                "surreal_intensity": round(len(dreamscape.surreal_anomalies) / 10, 3),
            },
            "confidence_metrics": {
                "confidence_score": dreamscape.confidence_score,
                "dream_intensity": dreamscape.dream_intensity,
                "mutation_depth": dreamscape.mutation_depth,
                "rehearsal_count": dreamscape.rehearsal_count,
            },
            "threat_assessment": {
                "threat_level": threat_level,
                "level_description": self._get_threat_level_description(threat_level),
                "recommended_actions": self._generate_recommendations(dreamscape, threat_level),
            },
            "narrative": {
                "description": dreamscape.description,
                "interpretation": self._interpret_dream(dreamscape),
            },
        }
        
        return report
    
    def _calculate_threat_level(self, dreamscape: Dreamscape) -> str:
        """Calculate overall threat level of the dreamscape."""
        score = (
            dreamscape.confidence_score * 0.4 +
            dreamscape.dream_intensity * 0.3 +
            min(1.0, len(dreamscape.surreal_anomalies) / 10) * 0.3
        )
        
        if score >= 0.8:
            return "CRITICAL"
        elif score >= 0.6:
            return "HIGH"
        elif score >= 0.4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _get_threat_level_description(self, level: str) -> str:
        """Get description for threat level."""
        descriptions = {
            "CRITICAL": "This dreamscape represents a highly plausible and dangerous threat scenario. Immediate defensive preparation recommended.",
            "HIGH": "This dreamscape contains concerning patterns that warrant proactive defense hardening.",
            "MEDIUM": "This dreamscape shows moderate threat potential. Consider adding to monitoring scenarios.",
            "LOW": "This dreamscape is highly surreal with low immediate threat value but useful for stress testing.",
        }
        return descriptions.get(level, "Unknown threat level")
    
    def _generate_recommendations(self, dreamscape: Dreamscape, threat_level: str) -> list[str]:
        """Generate security recommendations based on dreamscape analysis."""
        recommendations = []
        
        if threat_level in ["CRITICAL", "HIGH"]:
            recommendations.append("Run additional rehearsals against this dreamscape")
            recommendations.append("Update behavioral detection rules for generated traits")
            recommendations.append("Brief security team on potential attack patterns")
        
        if dreamscape.mutation_depth >= 3:
            recommendations.append("Review defense capabilities against polymorphic threats")
        
        if len(dreamscape.source_threats) >= 3:
            recommendations.append("Analyze cross-family attack correlations")
        
        if dreamscape.rehearsal_count == 0:
            recommendations.append("Execute at least one rehearsal run")
        
        recommendations.append("Archive dreamscape for future threat intelligence")
        
        return recommendations
    
    def _interpret_dream(self, dreamscape: Dreamscape) -> str:
        """Generate a psychological interpretation of the dream."""
        interpretations = [
            f"The fusion of {len(dreamscape.source_threats)} threat families suggests "
            f"the security system's subconscious recognition of convergent attack evolution.",
            
            f"With {len(dreamscape.surreal_anomalies)} surreal anomalies, this dream "
            f"reveals deep anxiety about unknown attack vectors and adaptive adversaries.",
            
            f"The {dreamscape.mutation_depth}-layer mutation depth indicates the system "
            f"is actively imagining increasingly sophisticated threat variations.",
            
            f"A confidence score of {dreamscape.confidence_score:.2f} suggests this "
            f"nightmare scenario feels disturbingly plausible to the defense systems.",
        ]
        
        return random.choice(interpretations)
    
    def get_all_dreamscapes(self) -> list[Dreamscape]:
        """Return all generated dreamscapes."""
        return self.dreamscapes
    
    def get_imagination_log(self) -> dict[str, list[str]]:
        """Return the complete imagination log across all sessions."""
        return self.imagination_log
    
    def export_dreamscape(self, dreamscape: Dreamscape) -> str:
        """Export a dreamscape as JSON for storage or transmission."""
        data = {
            "id": dreamscape.id,
            "source_threats": dreamscape.source_threats,
            "generated_traits": dreamscape.generated_traits,
            "surreal_anomalies": dreamscape.surreal_anomalies,
            "confidence_score": dreamscape.confidence_score,
            "timestamp": dreamscape.timestamp.isoformat(),
            "description": dreamscape.description,
            "dream_intensity": dreamscape.dream_intensity,
            "rehearsal_count": dreamscape.rehearsal_count,
            "mutation_depth": dreamscape.mutation_depth,
        }
        return json.dumps(data, indent=2)


# ============================================================================
# EXAMPLE USAGE / DEMONSTRATION
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("THREAT DREAMSCAPE ENGINE - Demonstration")
    print("Synthetic Threat Scenario Generation System")
    print("=" * 70)
    print()
    
    # Initialize the engine with depth 3 (moderate surrealism)
    print("[*] Initializing Threat Dreamscape Engine...")
    engine = ThreatDreamscapeEngine(dream_depth=3)
    print(f"    Session ID: {engine._session_id}")
    print(f"    Available threat memories: {list(engine.threat_memories.keys())}")
    print()
    
    # Step 1: Blend two synthetic threats
    print("[*] STEP 1: Blending threats (ransomware_alpha + apt_phantom)...")
    print("    Like the dreaming brain recombining memories into novel narratives...")
    dreamscape = engine.blend_threats(["ransomware_alpha", "apt_phantom"])
    print(f"    Created dreamscape: {dreamscape.id}")
    print(f"    Generated {len(dreamscape.generated_traits)} synthetic traits")
    print(f"    Initial anomalies: {len(dreamscape.surreal_anomalies)}")
    print()
    
    # Step 2: Exaggerate anomalies
    print("[*] STEP 2: Exaggerating anomalies into nightmare scenarios...")
    print("    Like dreams amplifying small worries into dramatic crises...")
    dreamscape = engine.exaggerate_anomalies(dreamscape)
    print(f"    Amplified to {len(dreamscape.surreal_anomalies)} surreal anomalies")
    print(f"    Dream intensity: {dreamscape.dream_intensity:.3f}")
    print()
    
    # Step 3: Run dreamscape rehearsal
    print("[*] STEP 3: Running dreamscape rehearsal...")
    print("    Like immune rehearsal during REM sleep...")
    rehearsal_result = engine.run_dreamscape(dreamscape)
    print(f"    Rehearsal #{rehearsal_result['rehearsal_number']} complete")
    print(f"    Defense success rate: {rehearsal_result['defense_success_rate']:.1%}")
    print(f"    Anomaly adaptation rate: {rehearsal_result['anomaly_adaptation_rate']:.1%}")
    print(f"    Overall effectiveness: {rehearsal_result['overall_effectiveness']:.1%}")
    print(f"    Adaptations generated: {len(rehearsal_result['adaptations_generated'])}")
    print()
    
    # Step 4: Generate report (dream journal entry)
    print("[*] STEP 4: Generating dream journal report...")
    report = engine.report(dreamscape)
    print()
    print("-" * 70)
    print("DREAM JOURNAL ENTRY")
    print("-" * 70)
    print(f"Dreamscape ID: {report['journal_entry']['dreamscape_id']}")
    print(f"Recorded at: {report['journal_entry']['recorded_at']}")
    print()
    print("SOURCE ANALYSIS:")
    print(f"  Blended threats: {', '.join(report['source_analysis']['blended_threats'])}")
    print(f"  DNA hash: {report['source_analysis']['dna_hash']}")
    print()
    print("TRAIT ANALYSIS:")
    print(f"  Total traits: {report['trait_analysis']['total_traits']}")
    print(f"  Base traits: {report['trait_analysis']['base_traits'][:3]}...")
    print(f"  Mutated traits: {report['trait_analysis']['mutated_traits'][:2]}...")
    print(f"  Mutation ratio: {report['trait_analysis']['mutation_ratio']:.1%}")
    print()
    print("SURREAL ANOMALIES:")
    for i, anomaly in enumerate(dreamscape.surreal_anomalies[:5], 1):
        display = anomaly[:60] + "..." if len(anomaly) > 60 else anomaly
        print(f"  {i}. {display}")
    if len(dreamscape.surreal_anomalies) > 5:
        print(f"  ... and {len(dreamscape.surreal_anomalies) - 5} more")
    print()
    print("CONFIDENCE METRICS:")
    print(f"  Confidence score: {report['confidence_metrics']['confidence_score']:.3f}")
    print(f"  Dream intensity: {report['confidence_metrics']['dream_intensity']:.3f}")
    print(f"  Mutation depth: {report['confidence_metrics']['mutation_depth']}")
    print()
    print("THREAT ASSESSMENT:")
    print(f"  Level: {report['threat_assessment']['threat_level']}")
    print(f"  {report['threat_assessment']['level_description']}")
    print()
    print("RECOMMENDED ACTIONS:")
    for action in report['threat_assessment']['recommended_actions']:
        print(f"  • {action}")
    print()
    print("NARRATIVE:")
    print(f"  {report['narrative']['description']}")
    print()
    print("INTERPRETATION:")
    print(f"  {report['narrative']['interpretation']}")
    print()
    print("-" * 70)
    print("IMAGINATION LOG (last 5 events):")
    for event in list(engine.imagination_log[engine._session_id])[-5:]:
        print(f"  {event}")
    print("-" * 70)
    print()
    print("[✓] Threat Dreamscape Engine demonstration complete.")
    print("    The security system has rehearsed against synthetic nightmares,")
    print("    strengthening its adaptive immunity against future unknown threats.")

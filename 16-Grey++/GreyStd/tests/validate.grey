// GreyStd Validation Test Suite
// Tests core functionality of GreyStd modules using Grey++ syntax

// ============================================================
// Core Module Tests
// ============================================================

fn test_string() {
  fn s() { string_new("hello world") }
  fn chars_list() { string_chars(s()) }
  fn reversed() { string_reverse(s()) }
  fn capitalized() { string_capitalize(s()) }
  fn sb() { sb_push(sb_push(StringBuilder_new(), "foo"), "bar") }
  fn built() { sb_build(sb()) }

  [
    test_eq(get(s(), "value"), "hello world", "string_new stores value"),
    test_eq(length(chars_list()), 11, "string_chars length"),
    test_eq(get(reversed(), "value"), "dlrow olleh", "string_reverse"),
    test_eq(get(capitalized(), "value"), "Hello world", "string_capitalize"),
    test_eq(built(), "foobar", "StringBuilder builds correctly")
  ]
}

fn test_option() {
  fn some_val() { Some(42) }
  fn none_val() { None() }
  fn mapped() { option_map(some_val(), fn(x) { mul(x, 2) }) }

  [
    test_true(is_some(some_val()), "Some is some"),
    test_true(is_none(none_val()), "None is none"),
    test_eq(option_unwrap(some_val()), 42, "unwrap Some"),
    test_eq(option_unwrap_or(none_val(), 0), 0, "unwrap_or None"),
    test_eq(option_unwrap(mapped()), 84, "option_map doubles")
  ]
}

fn test_result() {
  fn ok_val() { Ok(10) }
  fn err_val() { Err("oops") }
  fn mapped() { result_map(ok_val(), fn(x) { add(x, 5) }) }

  [
    test_true(is_ok(ok_val()), "Ok is ok"),
    test_true(is_err(err_val()), "Err is err"),
    test_eq(result_unwrap(ok_val()), 10, "unwrap Ok"),
    test_eq(result_unwrap(mapped()), 15, "result_map adds 5")
  ]
}

fn test_vec() {
  fn v() { vec_new() }
  fn v1() { vec_push(v(), 1) }
  fn v2() { vec_push(v1(), 2) }
  fn v3() { vec_push(v2(), 3) }

  [
    test_eq(length(get(v(), "items")), 0, "vec_new is empty"),
    test_eq(length(get(v3(), "items")), 3, "vec_push adds items"),
    test_eq(get(get(v3(), "items"), 0), 1, "first item is 1"),
    test_eq(get(get(v3(), "items"), 2), 3, "last item is 3")
  ]
}

fn test_map_module() {
  fn m() { map_new() }
  fn m1() { map_from_entries([["a", 1], ["b", 2], ["c", 3]]) }
  fn filtered() { map_filter(m1(), fn(k, v) { gt(v, 1) }) }

  [
    test_eq(length(keys(get(m(), "data"))), 0, "map_new is empty"),
    test_eq(map_get_or(m1(), "a", 0), 1, "map_get_or finds key"),
    test_eq(map_get_or(m1(), "z", 99), 99, "map_get_or returns default")
  ]
}

fn test_set_module() {
  fn s1() { set_from([1, 2, 3]) }
  fn s2() { set_from([2, 3, 4]) }
  fn union_set() { set_union(s1(), s2()) }
  fn inter_set() { set_intersection(s1(), s2()) }

  [
    test_true(set_contains(s1(), 1), "set contains 1"),
    test_false(set_contains(s1(), 5), "set does not contain 5"),
    test_true(set_contains(union_set(), 4), "union contains 4"),
    test_true(set_contains(inter_set(), 2), "intersection contains 2"),
    test_false(set_contains(inter_set(), 1), "intersection excludes 1")
  ]
}

fn test_math() {
  [
    test_eq(gcd(12, 8), 4, "gcd(12,8) = 4"),
    test_eq(lcm(4, 6), 12, "lcm(4,6) = 12"),
    test_eq(factorial(5), 120, "factorial(5) = 120"),
    test_eq(fibonacci(10), 55, "fibonacci(10) = 55"),
    test_true(is_even(4), "4 is even"),
    test_true(is_odd(7), "7 is odd"),
    test_eq(sign(-5), -1, "sign(-5) = -1"),
    test_eq(sign(3), 1, "sign(3) = 1")
  ]
}

// ============================================================
// Mem Module Tests
// ============================================================

fn test_smart_ptr() {
  fn b() { Box_new(42) }
  fn mapped() { box_map(b(), fn(x) { add(x, 8) }) }
  fn rc() { Rc_new("shared") }
  fn rc2() { rc_clone(rc()) }

  [
    test_eq(box_unwrap(b()), 42, "Box holds value"),
    test_eq(box_unwrap(mapped()), 50, "box_map transforms"),
    test_eq(rc_count(rc()), 1, "Rc starts at 1"),
    test_eq(rc_count(rc2()), 2, "rc_clone increments")
  ]
}

fn test_arena() {
  fn a() { Arena_new() }
  fn r1() { arena_alloc(a(), "first") }
  fn a1() { get(r1(), "arena") }
  fn h1() { get(r1(), "handle") }
  fn r2() { arena_alloc(a1(), "second") }
  fn a2() { get(r2(), "arena") }

  [
    test_eq(arena_count(a()), 0, "arena starts empty"),
    test_eq(arena_get(a1(), h1()), "first", "arena stores values"),
    test_eq(arena_count(a2()), 2, "arena tracks count")
  ]
}

// ============================================================
// Time Module Tests
// ============================================================

fn test_duration() {
  fn d1() { Duration_secs(5) }
  fn d2() { Duration_ms(3000) }
  fn added() { duration_add(d1(), d2()) }

  [
    test_eq(duration_ms(d1()), 5000, "5 secs = 5000ms"),
    test_eq(duration_ms(d2()), 3000, "3000ms"),
    test_eq(duration_ms(added()), 8000, "5s + 3s = 8s"),
    test_true(duration_gt(d1(), d2()), "5s > 3s"),
    test_true(duration_is_zero(Duration_zero()), "zero is zero")
  ]
}

fn test_version() {
  fn v1() { Version_new(1, 2, 3) }
  fn v2() { Version_new(1, 3, 0) }
  fn v3() { version_parse("2.0.0") }
  fn bumped() { version_bump_minor(v1()) }

  [
    test_eq(version_to_string(v1()), "1.2.3", "version format"),
    test_eq(version_compare(v1(), v2()), -1, "1.2.3 < 1.3.0"),
    test_eq(version_to_string(v3()), "2.0.0", "parse 2.0.0"),
    test_eq(version_to_string(bumped()), "1.3.0", "bump minor"),
    test_true(version_is_stable(v1()), "no prerelease = stable")
  ]
}

// ============================================================
// Serial Module Tests
// ============================================================

fn test_json() {
  fn obj() { { name: "test", value: 42 } }
  fn json_str() { json_serialize(obj()) }
  fn parsed() { json_parse(json_str()) }
  fn flat() { json_flatten({ a: { b: { c: 1 } } }) }

  [
    test_true(json_is_valid(json_str()), "serialized JSON is valid"),
    test_eq(get(parsed(), "name"), "test", "round-trip name"),
    test_eq(get(parsed(), "value"), 42, "round-trip value"),
    test_eq(get(flat(), "a.b.c"), 1, "flatten nested key")
  ]
}

fn test_binary() {
  fn enc() { BinaryEncoder_new() }
  fn e1() { encoder_write_u8(enc(), 42) }
  fn e2() { encoder_write_u16(e1(), 1000) }
  fn e3() { encoder_write_bool(e2(), true) }
  fn bytes() { encoder_bytes(e3()) }
  fn dec() { BinaryDecoder_new(bytes()) }
  fn r1() { decoder_read_u8(dec()) }
  fn r2() { decoder_read_u16(get(r1(), "decoder")) }
  fn r3() { decoder_read_bool(get(r2(), "decoder")) }

  [
    test_eq(get(r1(), "value"), 42, "decode u8"),
    test_eq(get(r2(), "value"), 1000, "decode u16"),
    test_true(get(r3(), "value"), "decode bool true")
  ]
}

// ============================================================
// Error & Test Module Tests
// ============================================================

fn test_error_types() {
  fn e() { Error_new("something failed") }
  fn te() { TypeError("expected number") }
  fn wrapped() { error_wrap(te(), "in function foo") }
  fn root() { error_root_cause(wrapped()) }

  [
    test_eq(error_message(e()), "something failed", "error message"),
    test_eq(error_kind(te()), "TypeError", "error kind"),
    test_str_contains(error_message(wrapped()), "in function foo", "wrapped message"),
    test_eq(error_kind(root()), "TypeError", "root cause kind")
  ]
}

fn test_try_run() {
  fn ok_result() { try_run(fn() { add(1, 2) }) }
  fn err_result() { try_run(fn() { panic("boom") }) }

  [
    test_true(is_ok(ok_result()), "try_run success is Ok"),
    test_eq(result_unwrap(ok_result()), 3, "try_run value"),
    test_true(is_err(err_result()), "try_run failure is Err")
  ]
}

// ============================================================
// Reflect Module Tests
// ============================================================

fn test_inspect() {
  fn obj() { { _type: "Widget", name: "foo", count: 3 } }
  fn i() { inspect(obj()) }
  fn dt() { detailed_type(42) }
  fn ds() { detailed_type("hello") }

  [
    test_eq(get(i(), "value_type"), "object", "inspect type"),
    test_eq(dt(), "integer", "42 is integer"),
    test_eq(ds(), "string(5)", "hello is string(5)"),
    test_true(deep_eq([1, 2, 3], [1, 2, 3]), "deep_eq arrays"),
    test_false(deep_eq([1, 2], [1, 3]), "deep_eq different arrays")
  ]
}

// ============================================================
// Deterministic Module Tests
// ============================================================

fn test_ordered_map() {
  fn om() { OrderedMap_new() }
  fn om1() { omap_insert(om(), "b", 2) }
  fn om2() { omap_insert(om1(), "a", 1) }
  fn om3() { omap_insert(om2(), "c", 3) }
  fn k() { omap_keys(om3()) }

  [
    test_eq(omap_size(om()), 0, "empty ordered map"),
    test_eq(omap_get(om3(), "a"), 1, "get from ordered map"),
    test_eq(get(k(), 0), "b", "first key is b (insertion order)"),
    test_eq(get(k(), 1), "a", "second key is a"),
    test_eq(get(k(), 2), "c", "third key is c")
  ]
}

fn test_pool_allocator() {
  fn pool() { PoolAllocator_new(4) }
  fn r1() { pool_alloc(pool(), "A") }
  fn p1() { get(r1(), "allocator") }
  fn h1() { get(r1(), "handle") }
  fn r2() { pool_alloc(p1(), "B") }
  fn p2() { get(r2(), "allocator") }

  [
    test_eq(pool_allocated(pool()), 0, "pool starts empty"),
    test_eq(pool_get(p1(), h1()), "A", "pool stores value"),
    test_eq(pool_allocated(p2()), 2, "pool tracks count"),
    test_eq(pool_free_count(p2()), 2, "pool tracks free slots")
  ]
}

// ============================================================
// Run All Tests
// ============================================================

fn main() {
  println("=== GreyStd Validation Suite ===\n")

  fn suites() {
    [
      it("core/string", test_string),
      it("core/option", test_option),
      it("core/result", test_result),
      it("core/vec", test_vec),
      it("core/map", test_map_module),
      it("core/set", test_set_module),
      it("core/math", test_math),
      it("mem/smart_ptr", test_smart_ptr),
      it("mem/arena", test_arena),
      it("time/duration", test_duration),
      it("module/version", test_version),
      it("serial/json", test_json),
      it("serial/binary", test_binary),
      it("error/types", test_error_types),
      it("error/try_run", test_try_run),
      it("reflect/inspect", test_inspect),
      it("deterministic/ordered_map", test_ordered_map),
      it("deterministic/pool_allocator", test_pool_allocator)
    ]
  }

  fn result() { run_tests("GreyStd Validation", suites()) }

  if_then(get(result(), "success"),
    fn() { println("\nAll GreyStd validation tests passed!") },
    fn() { println("\nSome GreyStd validation tests failed.") }
  )
}

main()

/// time::instant â€” A monotonic timestamp for measuring elapsed time.

use crate::time::duration::Duration;

/// Represents a point in time measured by a monotonic clock.
/// Instants are opaque and only meaningful relative to each other.
pub struct Instant {
    /// Nanoseconds since an arbitrary epoch (monotonic).
    nanos: u128,
}

impl Instant {
    /// Captures the current monotonic time.
    pub fn now() -> Instant {
        extern fn __grey_monotonic_nanos() -> u128;
        Instant { nanos: unsafe { __grey_monotonic_nanos() } }
    }

    /// Returns the duration elapsed since this instant was captured.
    pub fn elapsed(&self) -> Duration {
        let now = Instant::now();
        now.duration_since(self)
    }

    /// Returns the duration from `earlier` to `self`.
    /// Panics if `earlier` is after `self`.
    pub fn duration_since(&self, earlier: &Instant) -> Duration {
        assert!(self.nanos >= earlier.nanos, "duration_since: earlier instant is after self");
        Duration::from_nanos((self.nanos - earlier.nanos) as u64)
    }

    /// Returns the duration from `earlier` to `self`, or None if `earlier` is after `self`.
    pub fn checked_duration_since(&self, earlier: &Instant) -> Option<Duration> {
        if self.nanos >= earlier.nanos {
            Some(Duration::from_nanos((self.nanos - earlier.nanos) as u64))
        } else {
            None
        }
    }

    /// Returns the duration from `earlier` to `self`, saturating at zero.
    pub fn saturating_duration_since(&self, earlier: &Instant) -> Duration {
        self.checked_duration_since(earlier).unwrap_or(Duration::ZERO)
    }

    /// Returns the instant computed by adding a duration.
    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {
        self.nanos.checked_add(duration.as_nanos() as u128).map(|n| Instant { nanos: n })
    }

    /// Returns the instant computed by subtracting a duration.
    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {
        self.nanos.checked_sub(duration.as_nanos() as u128).map(|n| Instant { nanos: n })
    }

    /// Raw nanosecond value (for internal use).
    pub(crate) fn raw_nanos(&self) -> u128 {
        self.nanos
    }
}

impl Add<Duration> for Instant {
    type Output = Instant;
    fn add(self, rhs: Duration) -> Instant {
        self.checked_add(rhs).expect("overflow when adding duration to instant")
    }
}

impl Sub<Duration> for Instant {
    type Output = Instant;
    fn sub(self, rhs: Duration) -> Instant {
        self.checked_sub(rhs).expect("overflow when subtracting duration from instant")
    }
}

impl Sub<Instant> for Instant {
    type Output = Duration;
    fn sub(self, rhs: Instant) -> Duration {
        self.duration_since(&rhs)
    }
}

impl PartialEq for Instant {
    fn eq(&self, other: &Instant) -> bool { self.nanos == other.nanos }
}

impl Eq for Instant {}

impl PartialOrd for Instant {
    fn partial_cmp(&self, other: &Instant) -> Option<Ordering> {
        self.nanos.partial_cmp(&other.nanos)
    }
}

impl Ord for Instant {
    fn cmp(&self, other: &Instant) -> Ordering {
        self.nanos.cmp(&other.nanos)
    }
}

impl Clone for Instant {
    fn clone(&self) -> Instant { Instant { nanos: self.nanos } }
}

impl Copy for Instant {}

impl Debug for Instant {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "Instant({} ns)", self.nanos)
    }
}

/// Measures the time taken to execute a closure, returning (result, duration).
pub fn measure<T, F: FnOnce() -> T>(f: F) -> (T, Duration) {
    let start = Instant::now();
    let result = f();
    let elapsed = start.elapsed();
    (result, elapsed)
}

/// Measures the time taken to execute an async closure, returning (result, duration).
pub async fn measure_async<T, F: AsyncFnOnce() -> T>(f: F) -> (T, Duration) {
    let start = Instant::now();
    let result = f().await;
    let elapsed = start.elapsed();
    (result, elapsed)
}

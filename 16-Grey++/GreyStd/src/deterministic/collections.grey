// GreyStd Deterministic - Collections
// Ordered, deterministic collections with stable iteration

// Deterministic ordered map (preserves insertion order, stable iteration)
fn OrderedMap_new() {
  {
    _type: "OrderedMap",
    entries: [],
    index: {}
  }
}

// Insert into ordered map
fn omap_insert(om, key, value) {
  fn existing_idx() { get(get(om, "index"), key) }
  if_then(not(eq(existing_idx(), nil)),
    fn() {
      // Update existing entry
      fn new_entries() {
        map(range(0, length(get(om, "entries"))), fn(i) {
          if_then(eq(i, existing_idx()),
            fn() { { key: key, value: value } },
            fn() { get(get(om, "entries"), i) }
          )
        })
      }
      merge(om, { entries: new_entries() })
    },
    fn() {
      // Insert new entry
      fn new_idx() { length(get(om, "entries")) }
      merge(om, {
        entries: append(get(om, "entries"), { key: key, value: value }),
        index: merge(get(om, "index"), fromEntries([[key, new_idx()]]))
      })
    }
  )
}

// Get from ordered map
fn omap_get(om, key) {
  fn idx() { get(get(om, "index"), key) }
  if_then(eq(idx(), nil), fn() { nil }, fn() { get(get(get(om, "entries"), idx()), "value") })
}

// Check if key exists
fn omap_has(om, key) {
  not(eq(get(get(om, "index"), key), nil))
}

// Get all keys in insertion order
fn omap_keys(om) {
  map(get(om, "entries"), fn(e) { get(e, "key") })
}

// Get all values in insertion order
fn omap_values(om) {
  map(get(om, "entries"), fn(e) { get(e, "value") })
}

// Get all entries in insertion order
fn omap_entries(om) {
  get(om, "entries")
}

// Get size
fn omap_size(om) {
  length(get(om, "entries"))
}

// Iterate in deterministic order
fn omap_forEach(om, f) {
  forEach(get(om, "entries"), fn(e) { f(get(e, "key"), get(e, "value")) })
}

// Map values
fn omap_map(om, f) {
  fn new_entries() { map(get(om, "entries"), fn(e) { { key: get(e, "key"), value: f(get(e, "key"), get(e, "value")) } }) }
  fn new_index() { get(om, "index") }
  { _type: "OrderedMap", entries: new_entries(), index: new_index() }
}

// Deterministic sorted set
fn SortedSet_new(compare_fn) {
  {
    _type: "SortedSet",
    items: [],
    compare: compare_fn
  }
}

// Default sorted set (numeric order)
fn SortedSet_default() {
  SortedSet_new(fn(a, b) { sub(a, b) })
}

// Insert into sorted set (maintains sort)
fn sset_insert(ss, value) {
  fn items() { get(ss, "items") }
  if_then(contains(items(), value), fn() { ss }, fn() {
    fn new_items() { sort_by(append(items(), value), get(ss, "compare")) }
    merge(ss, { items: new_items() })
  })
}

// Sort by comparison function
fn sort_by(arr, cmp) {
  if_then(lte(length(arr), 1), fn() { arr }, fn() {
    fn pivot() { get(arr, 0) }
    fn rest() { slice(arr, 1) }
    fn less() { filter(rest(), fn(x) { lt(cmp(x, pivot()), 0) }) }
    fn greater() { filter(rest(), fn(x) { gte(cmp(x, pivot()), 0) }) }
    concat(concat(sort_by(less(), cmp), [pivot()]), sort_by(greater(), cmp))
  })
}

// Get sorted items
fn sset_items(ss) { get(ss, "items") }

// Get size
fn sset_size(ss) { length(get(ss, "items")) }

// Check membership
fn sset_contains(ss, value) { contains(get(ss, "items"), value) }

// Remove from sorted set
fn sset_remove(ss, value) {
  merge(ss, { items: filter(get(ss, "items"), fn(x) { not(eq(x, value)) }) })
}

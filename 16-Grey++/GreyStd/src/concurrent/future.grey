// concurrent::future — Async computation protocol
//
// A Future represents a value that may not be available yet.
// In Grey++, futures are objects with a poll() function.
//
// Future protocol:
//   { _type: "Future", poll: fn() { { ready: true, value: v } | { ready: false } } }

// Creates a future that immediately resolves with a value.
fn future_ready(value) {
    {
        _type: "Future",
        poll: fn() { { ready: true, value: value } }
    }
}

// Creates a future that never resolves.
fn future_pending() {
    {
        _type: "Future",
        poll: fn() { { ready: false } }
    }
}

// Creates a future from a function.
fn future_from_fn(f) {
    {
        _type: "Future",
        poll: fn() {
            fn result() { f() }
            { ready: true, value: result() }
        }
    }
}

// Maps a function over a future's resolved value.
fn future_map(fut, f) {
    {
        _type: "Future",
        poll: fn() {
            fn result() { get(fut, "poll")() }
            if_then(get(result(), "ready"),
                fn() { { ready: true, value: f(get(result(), "value")) } },
                fn() { { ready: false } })
        }
    }
}

// Chains futures (flat map).
fn future_and_then(fut, f) {
    {
        _type: "Future",
        poll: fn() {
            fn result() { get(fut, "poll")() }
            if_then(get(result(), "ready"),
                fn() {
                    fn next_fut() { f(get(result(), "value")) }
                    get(next_fut(), "poll")()
                },
                fn() { { ready: false } })
        }
    }
}

// Races two futures — returns whichever resolves first.
fn future_race(a, b) {
    {
        _type: "Future",
        poll: fn() {
            fn result_a() { get(a, "poll")() }
            if_then(get(result_a(), "ready"),
                fn() { result_a() },
                fn() { get(b, "poll")() })
        }
    }
}

// Joins two futures — waits for both and returns a pair.
fn future_join(a, b) {
    {
        _type: "Future",
        poll: fn() {
            fn result_a() { get(a, "poll")() }
            fn result_b() { get(b, "poll")() }
            if_then(get(result_a(), "ready"),
                fn() { if_then(get(result_b(), "ready"),
                    fn() { { ready: true, value: [get(result_a(), "value"), get(result_b(), "value")] } },
                    fn() { { ready: false } }) },
                fn() { { ready: false } })
        }
    }
}

// Joins an array of futures.
fn future_join_all(futures) {
    {
        _type: "Future",
        poll: fn() {
            fn results() { map(futures, fn(f) { get(f, "poll")() }) }
            fn all_ready() { every(results(), fn(r) { get(r, "ready") }) }
            if_then(all_ready(),
                fn() { { ready: true, value: map(results(), fn(r) { get(r, "value") }) } },
                fn() { { ready: false } })
        }
    }
}

// Polls a future and returns its result.
fn future_poll(fut) { get(fut, "poll")() }

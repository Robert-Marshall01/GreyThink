// mem::ref_wrapper â€” Reference wrapper utilities
//
// Provides a mutable reference wrapper (Cell/RefCell pattern)
// for Grey++ where values are normally immutable.

// Creates a new mutable cell wrapping a value.
fn Cell_new(value) {
    { _type: "Cell", value: value }
}

// Gets the current value.
fn cell_get(cell) { get(cell, "value") }

// Sets a new value (returns a new cell).
fn cell_set(cell, value) {
    set(cell, "value", value)
}

// Updates the value by applying a function.
fn cell_update(cell, f) {
    cell_set(cell, f(cell_get(cell)))
}

// Swaps the value with another cell.
fn cell_swap(cell_a, cell_b) {
    {
        a: cell_set(cell_a, cell_get(cell_b)),
        b: cell_set(cell_b, cell_get(cell_a))
    }
}

// Creates a RefCell (reference cell with borrow tracking).
fn RefCell_new(value) {
    { _type: "RefCell", value: value, borrowed: false, mut_borrowed: false }
}

// Borrows the value immutably.
fn refcell_borrow(cell) {
    if_then(get(cell, "mut_borrowed"),
        fn() { error("Cannot borrow: already mutably borrowed") },
        fn() { merge(cell, { borrowed: true }) })
}

// Borrows the value mutably.
fn refcell_borrow_mut(cell) {
    if_then(get(cell, "borrowed"),
        fn() { error("Cannot mutably borrow: already borrowed") },
        fn() { if_then(get(cell, "mut_borrowed"),
            fn() { error("Cannot mutably borrow: already mutably borrowed") },
            fn() { merge(cell, { mut_borrowed: true }) }) })
}

// Gets the value from a RefCell.
fn refcell_get(cell) { get(cell, "value") }

// Sets the value in a RefCell.
fn refcell_set(cell, value) { set(cell, "value", value) }

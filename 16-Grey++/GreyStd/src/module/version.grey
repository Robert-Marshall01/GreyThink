/// module::version — Semantic versioning (SemVer 2.0) with version requirements.

use crate::core::string::String;
use crate::core::vec::Vec;
use crate::core::option::Option;

/// A semantic version (major.minor.patch[-pre][+build]).
pub struct Version {
    pub major: u64,
    pub minor: u64,
    pub patch: u64,
    pub pre: Option<String>,
    pub build: Option<String>,
}

impl Version {
    pub fn new(major: u64, minor: u64, patch: u64) -> Version {
        Version { major, minor, patch, pre: None, build: None }
    }

    /// Parse a semver string (e.g. "1.2.3-alpha.1+build.456").
    pub fn parse(s: &str) -> Result<Version, VersionError> {
        // Split off build metadata
        let (version_pre, build) = if let Some(pos) = s.find('+') {
            (&s[..pos], Some(String::from(&s[pos + 1..])))
        } else {
            (s, None)
        };

        // Split off pre-release
        let (version_str, pre) = if let Some(pos) = version_pre.find('-') {
            (&version_pre[..pos], Some(String::from(&version_pre[pos + 1..])))
        } else {
            (version_pre, None)
        };

        let parts: Vec<&str> = version_str.split('.').collect();
        if parts.len() != 3 {
            return Err(VersionError::InvalidFormat(String::from(s)));
        }

        let major = parts[0].parse::<u64>()
            .map_err(|_| VersionError::InvalidFormat(String::from("invalid major version")))?;
        let minor = parts[1].parse::<u64>()
            .map_err(|_| VersionError::InvalidFormat(String::from("invalid minor version")))?;
        let patch = parts[2].parse::<u64>()
            .map_err(|_| VersionError::InvalidFormat(String::from("invalid patch version")))?;

        Ok(Version { major, minor, patch, pre, build })
    }

    /// Whether this is a pre-release version.
    pub fn is_prerelease(&self) -> bool { self.pre.is_some() }

    /// Whether this is a stable release (>= 1.0.0, no pre-release).
    pub fn is_stable(&self) -> bool { self.major > 0 && self.pre.is_none() }

    /// Increment major version (resets minor and patch).
    pub fn bump_major(&self) -> Version {
        Version::new(self.major + 1, 0, 0)
    }

    /// Increment minor version (resets patch).
    pub fn bump_minor(&self) -> Version {
        Version::new(self.major, self.minor + 1, 0)
    }

    /// Increment patch version.
    pub fn bump_patch(&self) -> Version {
        Version::new(self.major, self.minor, self.patch + 1)
    }

    /// Format as a string.
    pub fn to_string(&self) -> String {
        let mut s = format!("{}.{}.{}", self.major, self.minor, self.patch);
        if let Some(pre) = &self.pre {
            s.push('-');
            s.push_str(pre);
        }
        if let Some(build) = &self.build {
            s.push('+');
            s.push_str(build);
        }
        s
    }
}

impl PartialEq for Version {
    fn eq(&self, other: &Version) -> bool {
        // Build metadata is ignored in equality/comparison per SemVer spec
        self.major == other.major && self.minor == other.minor &&
        self.patch == other.patch && self.pre == other.pre
    }
}

impl Eq for Version {}

impl PartialOrd for Version {
    fn partial_cmp(&self, other: &Version) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Version {
    fn cmp(&self, other: &Version) -> Ordering {
        let base = self.major.cmp(&other.major)
            .then(self.minor.cmp(&other.minor))
            .then(self.patch.cmp(&other.patch));

        if base != Ordering::Equal { return base; }

        // Pre-release has lower precedence than release
        match (&self.pre, &other.pre) {
            (None, None) => Ordering::Equal,
            (Some(_), None) => Ordering::Less,    // pre < release
            (None, Some(_)) => Ordering::Greater,  // release > pre
            (Some(a), Some(b)) => a.cmp(b),       // lexicographic for simplicity
        }
    }
}

impl Clone for Version {
    fn clone(&self) -> Version {
        Version {
            major: self.major, minor: self.minor, patch: self.patch,
            pre: self.pre.clone(), build: self.build.clone(),
        }
    }
}

impl Display for Version {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{}", self.to_string())
    }
}

/// Version error.
pub enum VersionError {
    InvalidFormat(String),
    InvalidOperator(String),
}

// ─── Version Requirements ───────────────────────────────────

/// A version requirement (e.g. "^1.2.3", ">=1.0, <2.0").
pub struct VersionReq {
    comparators: Vec<Comparator>,
}

struct Comparator {
    op: CompOp,
    version: Version,
}

enum CompOp {
    /// Exact match: =1.2.3
    Exact,
    /// Greater than: >1.0.0
    Gt,
    /// Greater or equal: >=1.0.0
    Gte,
    /// Less than: <2.0.0
    Lt,
    /// Less or equal: <=2.0.0
    Lte,
    /// Caret (compatible with): ^1.2.3 means >=1.2.3, <2.0.0
    Caret,
    /// Tilde (approximately): ~1.2.3 means >=1.2.3, <1.3.0
    Tilde,
    /// Wildcard: 1.2.* means >=1.2.0, <1.3.0
    Wildcard,
}

impl VersionReq {
    /// Parse a version requirement string.
    pub fn parse(s: &str) -> Result<VersionReq, VersionError> {
        let mut comparators = Vec::new();

        for part in s.split(',') {
            let part = part.trim();
            let comp = Comparator::parse(part)?;
            comparators.push(comp);
        }

        if comparators.is_empty() {
            return Err(VersionError::InvalidFormat(String::from("empty version requirement")));
        }

        Ok(VersionReq { comparators })
    }

    /// Match any version.
    pub fn any() -> VersionReq {
        VersionReq { comparators: vec![Comparator { op: CompOp::Gte, version: Version::new(0, 0, 0) }] }
    }

    /// Check if a version satisfies this requirement.
    pub fn matches(&self, version: &Version) -> bool {
        self.comparators.iter().all(|c| c.matches(version))
    }

    /// Find the best match from a list of versions.
    pub fn best_match<'a>(&self, versions: &'a [Version]) -> Option<&'a Version> {
        versions.iter()
            .filter(|v| self.matches(v))
            .max()
    }
}

impl Comparator {
    fn parse(s: &str) -> Result<Comparator, VersionError> {
        let s = s.trim();

        if s.starts_with("^") {
            let v = Version::parse(&s[1..])?;
            Ok(Comparator { op: CompOp::Caret, version: v })
        } else if s.starts_with("~") {
            let v = Version::parse(&s[1..])?;
            Ok(Comparator { op: CompOp::Tilde, version: v })
        } else if s.starts_with(">=") {
            let v = Version::parse(s[2..].trim())?;
            Ok(Comparator { op: CompOp::Gte, version: v })
        } else if s.starts_with(">") {
            let v = Version::parse(s[1..].trim())?;
            Ok(Comparator { op: CompOp::Gt, version: v })
        } else if s.starts_with("<=") {
            let v = Version::parse(s[2..].trim())?;
            Ok(Comparator { op: CompOp::Lte, version: v })
        } else if s.starts_with("<") {
            let v = Version::parse(s[1..].trim())?;
            Ok(Comparator { op: CompOp::Lt, version: v })
        } else if s.starts_with("=") {
            let v = Version::parse(s[1..].trim())?;
            Ok(Comparator { op: CompOp::Exact, version: v })
        } else if s.contains('*') {
            let parts: Vec<&str> = s.split('.').collect();
            let major = parts.get(0).and_then(|p| p.parse::<u64>().ok()).unwrap_or(0);
            let minor = parts.get(1).and_then(|p| p.parse::<u64>().ok()).unwrap_or(0);
            Ok(Comparator { op: CompOp::Wildcard, version: Version::new(major, minor, 0) })
        } else {
            // Default to caret
            let v = Version::parse(s)?;
            Ok(Comparator { op: CompOp::Caret, version: v })
        }
    }

    fn matches(&self, v: &Version) -> bool {
        match self.op {
            CompOp::Exact => *v == self.version,
            CompOp::Gt => *v > self.version,
            CompOp::Gte => *v >= self.version,
            CompOp::Lt => *v < self.version,
            CompOp::Lte => *v <= self.version,
            CompOp::Caret => {
                if self.version.major > 0 {
                    v.major == self.version.major && *v >= self.version
                } else if self.version.minor > 0 {
                    v.major == 0 && v.minor == self.version.minor && *v >= self.version
                } else {
                    *v == self.version
                }
            }
            CompOp::Tilde => {
                v.major == self.version.major &&
                v.minor == self.version.minor &&
                *v >= self.version
            }
            CompOp::Wildcard => {
                v.major == self.version.major && v.minor == self.version.minor
            }
        }
    }
}

impl Display for VersionReq {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        let parts: Vec<String> = self.comparators.iter().map(|c| {
            let op = match c.op {
                CompOp::Exact => "=",
                CompOp::Gt => ">",
                CompOp::Gte => ">=",
                CompOp::Lt => "<",
                CompOp::Lte => "<=",
                CompOp::Caret => "^",
                CompOp::Tilde => "~",
                CompOp::Wildcard => "",
            };
            format!("{}{}", op, c.version.to_string())
        }).collect();
        write!(f, "{}", parts.join(", "))
    }
}

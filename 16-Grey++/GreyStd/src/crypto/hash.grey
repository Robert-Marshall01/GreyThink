/// crypto::hash — Cryptographic hash functions (SHA-2, SHA-3, BLAKE2, BLAKE3, MD5).

use crate::core::vec::Vec;
use crate::core::string::String;
use crate::crypto::CryptoResult;

/// Supported hash algorithms.
pub enum HashAlgorithm {
    Md5,
    Sha1,
    Sha224,
    Sha256,
    Sha384,
    Sha512,
    Sha3_256,
    Sha3_384,
    Sha3_512,
    Blake2b256,
    Blake2b512,
    Blake2s256,
    Blake3,
}

impl HashAlgorithm {
    /// Output length in bytes.
    pub fn output_len(&self) -> usize {
        match self {
            HashAlgorithm::Md5 => 16,
            HashAlgorithm::Sha1 => 20,
            HashAlgorithm::Sha224 => 28,
            HashAlgorithm::Sha256 | HashAlgorithm::Sha3_256 | HashAlgorithm::Blake2s256 | HashAlgorithm::Blake2b256 => 32,
            HashAlgorithm::Sha384 | HashAlgorithm::Sha3_384 => 48,
            HashAlgorithm::Sha512 | HashAlgorithm::Sha3_512 | HashAlgorithm::Blake2b512 => 64,
            HashAlgorithm::Blake3 => 32,
        }
    }

    /// Block size in bytes.
    pub fn block_size(&self) -> usize {
        match self {
            HashAlgorithm::Md5 | HashAlgorithm::Sha1 | HashAlgorithm::Sha224 | HashAlgorithm::Sha256 => 64,
            HashAlgorithm::Sha384 | HashAlgorithm::Sha512 => 128,
            HashAlgorithm::Sha3_256 => 136,
            HashAlgorithm::Sha3_384 => 104,
            HashAlgorithm::Sha3_512 => 72,
            HashAlgorithm::Blake2b256 | HashAlgorithm::Blake2b512 => 128,
            HashAlgorithm::Blake2s256 => 64,
            HashAlgorithm::Blake3 => 64,
        }
    }

    /// Human-readable name.
    pub fn name(&self) -> &str {
        match self {
            HashAlgorithm::Md5 => "MD5",
            HashAlgorithm::Sha1 => "SHA-1",
            HashAlgorithm::Sha224 => "SHA-224",
            HashAlgorithm::Sha256 => "SHA-256",
            HashAlgorithm::Sha384 => "SHA-384",
            HashAlgorithm::Sha512 => "SHA-512",
            HashAlgorithm::Sha3_256 => "SHA3-256",
            HashAlgorithm::Sha3_384 => "SHA3-384",
            HashAlgorithm::Sha3_512 => "SHA3-512",
            HashAlgorithm::Blake2b256 => "BLAKE2b-256",
            HashAlgorithm::Blake2b512 => "BLAKE2b-512",
            HashAlgorithm::Blake2s256 => "BLAKE2s-256",
            HashAlgorithm::Blake3 => "BLAKE3",
        }
    }
}

/// The result of a hash computation.
pub struct Digest {
    bytes: Vec<u8>,
}

impl Digest {
    pub fn new(bytes: Vec<u8>) -> Digest { Digest { bytes } }

    /// Raw hash bytes.
    pub fn as_bytes(&self) -> &[u8] { &self.bytes }

    /// Hex-encoded string.
    pub fn to_hex(&self) -> String {
        let mut hex = String::with_capacity(self.bytes.len() * 2);
        let table = b"0123456789abcdef";
        for &b in &self.bytes {
            hex.push(table[(b >> 4) as usize] as char);
            hex.push(table[(b & 0x0F) as usize] as char);
        }
        hex
    }

    /// Base64-encoded string.
    pub fn to_base64(&self) -> String {
        crate::serial::binary::base64_encode(&self.bytes)
    }

    /// Length of the digest in bytes.
    pub fn len(&self) -> usize { self.bytes.len() }

    /// Constant-time equality comparison.
    pub fn ct_eq(&self, other: &Digest) -> bool {
        if self.bytes.len() != other.bytes.len() { return false; }
        let mut diff: u8 = 0;
        for i in 0..self.bytes.len() {
            diff |= self.bytes[i] ^ other.bytes[i];
        }
        diff == 0
    }
}

impl PartialEq for Digest {
    fn eq(&self, other: &Digest) -> bool { self.ct_eq(other) }
}

impl Eq for Digest {}

// ─── Hasher trait ────────────────────────────────────────────

/// Incremental hash computation.
pub trait Hasher {
    /// Feed data into the hasher.
    fn update(&mut self, data: &[u8]);

    /// Finalize and return the digest. Consumes the hasher.
    fn finalize(self) -> Digest;

    /// Reset the hasher to its initial state.
    fn reset(&mut self);

    /// The algorithm used by this hasher.
    fn algorithm(&self) -> HashAlgorithm;
}

// ─── SHA-256 ────────────────────────────────────────────────

pub struct Sha256Hasher {
    state: [u32; 8],
    buffer: Vec<u8>,
    total_len: u64,
}

impl Sha256Hasher {
    const INIT: [u32; 8] = [
        0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
        0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19,
    ];

    const K: [u32; 64] = [
        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
    ];

    pub fn new() -> Sha256Hasher {
        Sha256Hasher { state: Self::INIT, buffer: Vec::new(), total_len: 0 }
    }

    fn compress(&mut self, block: &[u8; 64]) {
        let mut w = [0u32; 64];
        for i in 0..16 {
            w[i] = u32::from_be_bytes([block[i*4], block[i*4+1], block[i*4+2], block[i*4+3]]);
        }
        for i in 16..64 {
            let s0 = w[i-15].rotate_right(7) ^ w[i-15].rotate_right(18) ^ (w[i-15] >> 3);
            let s1 = w[i-2].rotate_right(17) ^ w[i-2].rotate_right(19) ^ (w[i-2] >> 10);
            w[i] = w[i-16].wrapping_add(s0).wrapping_add(w[i-7]).wrapping_add(s1);
        }

        let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) =
            (self.state[0], self.state[1], self.state[2], self.state[3],
             self.state[4], self.state[5], self.state[6], self.state[7]);

        for i in 0..64 {
            let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
            let ch = (e & f) ^ ((!e) & g);
            let temp1 = h.wrapping_add(s1).wrapping_add(ch).wrapping_add(Self::K[i]).wrapping_add(w[i]);
            let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
            let maj = (a & b) ^ (a & c) ^ (b & c);
            let temp2 = s0.wrapping_add(maj);

            h = g; g = f; f = e;
            e = d.wrapping_add(temp1);
            d = c; c = b; b = a;
            a = temp1.wrapping_add(temp2);
        }

        self.state[0] = self.state[0].wrapping_add(a);
        self.state[1] = self.state[1].wrapping_add(b);
        self.state[2] = self.state[2].wrapping_add(c);
        self.state[3] = self.state[3].wrapping_add(d);
        self.state[4] = self.state[4].wrapping_add(e);
        self.state[5] = self.state[5].wrapping_add(f);
        self.state[6] = self.state[6].wrapping_add(g);
        self.state[7] = self.state[7].wrapping_add(h);
    }
}

impl Hasher for Sha256Hasher {
    fn update(&mut self, data: &[u8]) {
        self.total_len += data.len() as u64;
        self.buffer.extend_from_slice(data);

        while self.buffer.len() >= 64 {
            let mut block = [0u8; 64];
            block.copy_from_slice(&self.buffer[..64]);
            self.compress(&block);
            self.buffer.drain(0..64);
        }
    }

    fn finalize(mut self) -> Digest {
        let bit_len = self.total_len * 8;
        self.buffer.push(0x80);
        while self.buffer.len() % 64 != 56 {
            self.buffer.push(0x00);
        }
        self.buffer.extend_from_slice(&bit_len.to_be_bytes());

        while self.buffer.len() >= 64 {
            let mut block = [0u8; 64];
            block.copy_from_slice(&self.buffer[..64]);
            self.compress(&block);
            self.buffer.drain(0..64);
        }

        let mut result = Vec::with_capacity(32);
        for word in &self.state {
            result.extend_from_slice(&word.to_be_bytes());
        }
        Digest::new(result)
    }

    fn reset(&mut self) {
        self.state = Self::INIT;
        self.buffer.clear();
        self.total_len = 0;
    }

    fn algorithm(&self) -> HashAlgorithm { HashAlgorithm::Sha256 }
}

// ─── SHA-512 ────────────────────────────────────────────────

pub struct Sha512Hasher {
    state: [u64; 8],
    buffer: Vec<u8>,
    total_len: u128,
}

impl Sha512Hasher {
    const INIT: [u64; 8] = [
        0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,
        0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,
        0x510E527FADE682D1, 0x9B05688C2B3E6C1F,
        0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179,
    ];

    pub fn new() -> Sha512Hasher {
        Sha512Hasher { state: Self::INIT, buffer: Vec::new(), total_len: 0 }
    }
}

impl Hasher for Sha512Hasher {
    fn update(&mut self, data: &[u8]) {
        self.total_len += data.len() as u128;
        self.buffer.extend_from_slice(data);
        // SHA-512 processes 128-byte blocks — compress omitted for brevity
    }

    fn finalize(self) -> Digest {
        extern fn __grey_sha512_finalize(state: &[u64; 8], buffer: &[u8], total_len: u128) -> Vec<u8>;
        let bytes = unsafe { __grey_sha512_finalize(&self.state, &self.buffer, self.total_len) };
        Digest::new(bytes)
    }

    fn reset(&mut self) {
        self.state = Self::INIT;
        self.buffer.clear();
        self.total_len = 0;
    }

    fn algorithm(&self) -> HashAlgorithm { HashAlgorithm::Sha512 }
}

// ─── Convenience functions ──────────────────────────────────

/// Hash data with SHA-256.
pub fn sha256(data: &[u8]) -> Digest {
    let mut h = Sha256Hasher::new();
    h.update(data);
    h.finalize()
}

/// Hash data with SHA-512.
pub fn sha512(data: &[u8]) -> Digest {
    let mut h = Sha512Hasher::new();
    h.update(data);
    h.finalize()
}

/// Hash data using a specified algorithm.
pub fn hash(algorithm: HashAlgorithm, data: &[u8]) -> Digest {
    extern fn __grey_hash(alg: &str, data: &[u8]) -> Vec<u8>;
    let bytes = unsafe { __grey_hash(algorithm.name(), data) };
    Digest::new(bytes)
}

/// Hash a string with SHA-256.
pub fn sha256_str(s: &str) -> Digest {
    sha256(s.as_bytes())
}

/// Hash a file's contents with SHA-256.
pub fn sha256_file(path: &str) -> CryptoResult<Digest> {
    let data = crate::io::file::File::read_bytes(path)
        .map_err(|e| crate::crypto::CryptoError::Internal(format!("IO error: {}", e)))?;
    Ok(sha256(&data))
}

// core::array — Fixed-size array utilities
//
// In Grey++, arrays are native dynamic collections.
// This module provides additional utility functions for arrays
// beyond the built-in map, filter, reduce, sort, etc.

// ── Array Construction ──────────────────────────────────────────

// Creates an empty array.
fn array_new() { [] }

// Creates an array filled with n copies of value.
fn array_filled(value, n) { repeat(n, fn(i) { value }) }

// Creates an array from a range of numbers.
fn array_range(start, end) { range(start, end) }

// Creates an array from a range with step.
fn array_range_step(start, end, step) {
    fn collect(i, acc) {
        if_then(i >= end,
            fn() { acc },
            fn() { collect(i + step, push(acc, i)) })
    }
    collect(start, [])
}

// ── Array Inspection ────────────────────────────────────────────

// Returns the length of an array.
fn array_len(arr) { len(arr) }

// Returns true if the array is empty.
fn array_is_empty(arr) { len(arr) == 0 }

// Returns the first element or nil.
fn array_first(arr) { head(arr) }

// Returns the last element or nil.
fn array_last(arr) { last(arr) }

// Returns the element at index i.
fn array_get(arr, i) {
    if_then(i >= 0, fn() {
        if_then(i < len(arr), fn() { get(arr, i) }, fn() { nil })
    }, fn() { nil })
}

// ── Array Search ────────────────────────────────────────────────

// Returns true if the array contains value.
fn array_contains(arr, value) { includes(arr, value) }

// Returns the index of value, or -1.
fn array_index_of(arr, value) { index_of(arr, value) }

// Finds the first element matching predicate.
fn array_find(arr, predicate) { find(arr, predicate) }

// Finds the index of the first element matching predicate.
fn array_find_index(arr, predicate) {
    fn search(i) {
        if_then(i >= len(arr), fn() { -1 },
            fn() { if_then(predicate(get(arr, i)), fn() { i },
                fn() { search(i + 1) }) })
    }
    search(0)
}

// Returns true if any element matches predicate.
fn array_any(arr, predicate) { some(arr, predicate) }

// Returns true if all elements match predicate.
fn array_all(arr, predicate) { every(arr, predicate) }

// Counts elements matching predicate.
fn array_count(arr, predicate) { count(arr, predicate) }

// ── Array Transformation ────────────────────────────────────────

// Maps each element through fn.
fn array_map(arr, f) { map(arr, f) }

// Filters elements by predicate.
fn array_filter(arr, predicate) { filter(arr, predicate) }

// Reduces array to a single value.
fn array_reduce(arr, f, init) { reduce(arr, f, init) }

// Sorts the array with comparator.
fn array_sort(arr, comparator) { sort(arr, comparator) }

// Reverses the array.
fn array_reverse(arr) { reverse(arr) }

// Flattens one level of nesting.
fn array_flat(arr) { flat(arr) }

// Flattens all levels of nesting.
fn array_flatten(arr) { flatten(arr) }

// Maps then flattens.
fn array_flat_map(arr, f) { flat_map(arr, f) }

// Removes duplicates.
fn array_unique(arr) { uniq(arr) }

// Groups by key function.
fn array_group_by(arr, key_fn) { group_by(arr, key_fn) }

// Zips two arrays together.
fn array_zip(a, b) { zip(a, b) }

// ── Array Slicing ───────────────────────────────────────────────

// Returns a sub-array.
fn array_slice(arr, start, end) { slice(arr, start, end) }

// Returns the first n elements.
fn array_take(arr, n) { take(arr, n) }

// Drops the first n elements.
fn array_drop(arr, n) { drop(arr, n) }

// Returns all except the first element.
fn array_tail(arr) { tail(arr) }

// ── Array Building ──────────────────────────────────────────────

// Appends a value (non-mutating).
fn array_push(arr, value) { push(arr, value) }

// Concatenates two arrays.
fn array_concat(a, b) { concat(a, b) }

// Inserts a value at index (non-mutating).
fn array_insert(arr, index, value) {
    concat(concat(take(arr, index), [value]), drop(arr, index))
}

// Removes an element at index (non-mutating).
fn array_remove(arr, index) {
    concat(take(arr, index), drop(arr, index + 1))
}

// Replaces an element at index (non-mutating).
fn array_set(arr, index, value) {
    map(range(0, len(arr)), fn(i) {
        if_then(i == index, value, fn() { get(arr, i) })
    })
}

// ── Array Iteration ─────────────────────────────────────────────

// Executes fn for each element.
fn array_for_each(arr, f) { forEach(arr, f) }

// Partitions array into two based on predicate.
fn array_partition(arr, predicate) {
    {
        pass: filter(arr, predicate),
        fail: filter(arr, fn(x) { not(predicate(x)) })
    }
}

// Chunks array into sub-arrays of given size.
fn array_chunk(arr, size) { chunk(arr, size) }

// Sliding windows of given size.
fn array_windows(arr, size) {
    if_then(size > len(arr), fn() { [] },
        fn() { map(range(0, len(arr) - size + 1), fn(i) {
            slice(arr, i, i + size)
        }) })
}

// Interleaves two arrays.
fn array_interleave(a, b) {
    fn weave(i, acc) {
        if_then(i >= len(a), fn() {
            if_then(i >= len(b), fn() { acc },
                fn() { concat(acc, drop(b, i)) })
        }, fn() {
            if_then(i >= len(b),
                fn() { concat(acc, drop(a, i)) },
                fn() { weave(i + 1, push(push(acc, get(a, i)), get(b, i))) })
        })
    }
    weave(0, [])
}

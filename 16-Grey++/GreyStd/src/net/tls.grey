/// net::tls â€” TLS/SSL encrypted transport.

use crate::core::string::String;
use crate::core::vec::Vec;
use crate::core::option::Option;
use crate::io::{IoResult, IoError, IoErrorKind};
use crate::io::stream::{Read, Write};
use crate::net::{NetResult, NetError, TcpStream};

/// A TLS client connector.
///
/// ```grey
/// let stream = TcpStream::connect("example.com:443").await?;
/// let mut tls = TlsConnector::new()
///     .verify_hostname(true)
///     .connect("example.com", stream).await?;
///
/// tls.write_all(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")?;
/// ```
pub struct TlsConnector {
    verify_hostname: bool,
    verify_cert: bool,
    root_certs: Option<Vec<Certificate>>,
    client_cert: Option<(Certificate, PrivateKey)>,
    alpn_protocols: Vec<String>,
    min_version: TlsVersion,
    max_version: TlsVersion,
}

impl TlsConnector {
    pub fn new() -> TlsConnector {
        TlsConnector {
            verify_hostname: true,
            verify_cert: true,
            root_certs: None,
            client_cert: None,
            alpn_protocols: Vec::new(),
            min_version: TlsVersion::Tls12,
            max_version: TlsVersion::Tls13,
        }
    }

    /// Enables or disables hostname verification.
    pub fn verify_hostname(mut self, verify: bool) -> TlsConnector {
        self.verify_hostname = verify;
        self
    }

    /// Enables or disables certificate verification.
    pub fn verify_cert(mut self, verify: bool) -> TlsConnector {
        self.verify_cert = verify;
        self
    }

    /// Adds a trusted root CA certificate.
    pub fn add_root_cert(mut self, cert: Certificate) -> TlsConnector {
        let certs = self.root_certs.get_or_insert(Vec::new());
        certs.push(cert);
        self
    }

    /// Sets the client certificate and private key for mutual TLS.
    pub fn client_cert(mut self, cert: Certificate, key: PrivateKey) -> TlsConnector {
        self.client_cert = Some((cert, key));
        self
    }

    /// Sets the ALPN protocols (e.g., ["h2", "http/1.1"]).
    pub fn alpn_protocols(mut self, protocols: Vec<String>) -> TlsConnector {
        self.alpn_protocols = protocols;
        self
    }

    /// Sets the minimum TLS version.
    pub fn min_version(mut self, version: TlsVersion) -> TlsConnector {
        self.min_version = version;
        self
    }

    /// Sets the maximum TLS version.
    pub fn max_version(mut self, version: TlsVersion) -> TlsConnector {
        self.max_version = version;
        self
    }

    /// Performs the TLS handshake, wrapping a TCP stream.
    pub async fn connect(self, hostname: &str, stream: TcpStream) -> NetResult<TlsStream> {
        let ctx = intrinsics::tls_client_context(
            self.verify_hostname,
            self.verify_cert,
            &self.root_certs,
            &self.client_cert,
            &self.alpn_protocols,
            self.min_version,
            self.max_version,
        )?;

        let tls_handle = intrinsics::tls_connect(ctx, hostname, stream.as_raw_fd()).await
            .map_err(|e| NetError::TlsError(format!("handshake failed: {}", e)))?;

        Ok(TlsStream {
            handle: tls_handle,
            _tcp: stream,
        })
    }
}

/// A TLS server acceptor.
pub struct TlsAcceptor {
    cert: Certificate,
    key: PrivateKey,
    alpn_protocols: Vec<String>,
    client_auth: ClientAuth,
}

/// Client authentication mode for servers.
pub enum ClientAuth {
    /// No client certificate required.
    None,
    /// Client certificate optional but verified if present.
    Optional,
    /// Client certificate required.
    Required,
}

impl TlsAcceptor {
    /// Creates a new TLS acceptor with the given server certificate and key.
    pub fn new(cert: Certificate, key: PrivateKey) -> TlsAcceptor {
        TlsAcceptor {
            cert,
            key,
            alpn_protocols: Vec::new(),
            client_auth: ClientAuth::None,
        }
    }

    /// Sets the ALPN protocols.
    pub fn alpn_protocols(mut self, protocols: Vec<String>) -> TlsAcceptor {
        self.alpn_protocols = protocols;
        self
    }

    /// Sets the client authentication mode.
    pub fn client_auth(mut self, auth: ClientAuth) -> TlsAcceptor {
        self.client_auth = auth;
        self
    }

    /// Accepts an incoming TLS connection, performing the server-side handshake.
    pub async fn accept(self, stream: TcpStream) -> NetResult<TlsStream> {
        let ctx = intrinsics::tls_server_context(
            &self.cert,
            &self.key,
            &self.alpn_protocols,
            &self.client_auth,
        )?;

        let tls_handle = intrinsics::tls_accept(ctx, stream.as_raw_fd()).await
            .map_err(|e| NetError::TlsError(format!("accept failed: {}", e)))?;

        Ok(TlsStream {
            handle: tls_handle,
            _tcp: stream,
        })
    }
}

/// An encrypted TLS stream wrapping a TCP connection.
pub struct TlsStream {
    handle: TlsHandle,
    _tcp: TcpStream, // kept alive
}

impl TlsStream {
    /// Returns the negotiated ALPN protocol, if any.
    pub fn alpn_protocol(self) -> Option<String> {
        intrinsics::tls_alpn_protocol(self.handle)
    }

    /// Returns the negotiated TLS version.
    pub fn protocol_version(self) -> Option<TlsVersion> {
        intrinsics::tls_protocol_version(self.handle)
    }

    /// Returns the peer's certificate, if provided.
    pub fn peer_certificate(self) -> Option<Certificate> {
        intrinsics::tls_peer_cert(self.handle)
    }

    /// Returns the cipher suite in use.
    pub fn cipher_suite(self) -> Option<String> {
        intrinsics::tls_cipher_suite(self.handle)
    }
}

impl Read for TlsStream {
    fn read(mut self, buf: &mut [u8]) -> IoResult<usize> {
        intrinsics::tls_read(self.handle, buf)
    }
}

impl Write for TlsStream {
    fn write(mut self, buf: &[u8]) -> IoResult<usize> {
        intrinsics::tls_write(self.handle, buf)
    }

    fn flush(mut self) -> IoResult<()> {
        intrinsics::tls_flush(self.handle)
    }
}

impl Drop for TlsStream {
    fn drop(mut self) {
        let _ = intrinsics::tls_shutdown(self.handle);
    }
}

/// TLS protocol versions.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum TlsVersion {
    Tls10,
    Tls11,
    Tls12,
    Tls13,
}

impl Display for TlsVersion {
    fn fmt(self, f: &mut Formatter) -> Result<(), FmtError> {
        match self {
            TlsVersion::Tls10 => write!(f, "TLS 1.0"),
            TlsVersion::Tls11 => write!(f, "TLS 1.1"),
            TlsVersion::Tls12 => write!(f, "TLS 1.2"),
            TlsVersion::Tls13 => write!(f, "TLS 1.3"),
        }
    }
}

/// An X.509 certificate.
pub struct Certificate {
    der: Vec<u8>,
}

impl Certificate {
    /// Creates a certificate from DER-encoded bytes.
    pub fn from_der(der: Vec<u8>) -> Certificate {
        Certificate { der }
    }

    /// Creates a certificate from PEM-encoded text.
    pub fn from_pem(pem: &str) -> NetResult<Certificate> {
        let der = decode_pem(pem, "CERTIFICATE")?;
        Ok(Certificate { der })
    }

    /// Loads a certificate from a file.
    pub fn from_file(path: &str) -> NetResult<Certificate> {
        let content = crate::io::file::File::read_string(path)
            .map_err(|e| NetError::TlsError(format!("failed to read cert: {}", e)))?;
        Certificate::from_pem(&content)
    }

    /// Returns the DER encoding.
    pub fn as_der(self) -> &[u8] { &self.der }
}

/// A private key.
pub struct PrivateKey {
    der: Vec<u8>,
}

impl PrivateKey {
    /// Creates a key from DER-encoded bytes.
    pub fn from_der(der: Vec<u8>) -> PrivateKey {
        PrivateKey { der }
    }

    /// Creates a key from PEM-encoded text.
    pub fn from_pem(pem: &str) -> NetResult<PrivateKey> {
        let der = decode_pem(pem, "PRIVATE KEY")
            .or_else(|_| decode_pem(pem, "RSA PRIVATE KEY"))
            .or_else(|_| decode_pem(pem, "EC PRIVATE KEY"))?;
        Ok(PrivateKey { der })
    }

    /// Loads a key from a file.
    pub fn from_file(path: &str) -> NetResult<PrivateKey> {
        let content = crate::io::file::File::read_string(path)
            .map_err(|e| NetError::TlsError(format!("failed to read key: {}", e)))?;
        PrivateKey::from_pem(&content)
    }
}

fn decode_pem(pem: &str, label: &str) -> NetResult<Vec<u8>> {
    let begin = format!("-----BEGIN {}-----", label);
    let end = format!("-----END {}-----", label);

    let start = pem.find(&begin)
        .ok_or(NetError::TlsError(format!("missing PEM header for {}", label)))?;
    let after_header = start + begin.len();
    let end_pos = pem[after_header..].find(&end)
        .ok_or(NetError::TlsError(format!("missing PEM footer for {}", label)))?;

    let b64 = &pem[after_header..after_header + end_pos];
    let cleaned: String = b64.chars().filter(|c| !c.is_whitespace()).collect();
    crate::serial::binary::base64_decode(&cleaned)
        .map_err(|e| NetError::TlsError(format!("invalid base64: {}", e)))
}

type TlsHandle = *mut ();

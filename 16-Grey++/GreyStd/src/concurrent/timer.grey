// concurrent::timer — Sleep, delay, interval, timeout
//
// Timer utilities for scheduling and delays.
// Uses the built-in sleep() function.

// Sleeps for the given number of milliseconds.
fn timer_sleep(ms) { sleep(ms) }

// Sleeps for the given number of seconds.
fn timer_sleep_secs(secs) { sleep(secs * 1000) }

// Creates a delay that resolves after ms milliseconds.
fn Delay_new(ms) {
    {
        _type: "Delay",
        duration_ms: ms,
        start: timestamp(),
        resolved: false
    }
}

// Checks if a delay has elapsed.
fn delay_is_elapsed(delay) {
    elapsed(get(delay, "start")) >= get(delay, "duration_ms")
}

// Waits for the delay to complete.
fn delay_wait(delay) {
    fn remaining() { get(delay, "duration_ms") - elapsed(get(delay, "start")) }
    when(remaining() > 0, fn() { sleep(remaining()) })
    set(delay, "resolved", true)
}

// Creates a periodic interval.
fn Interval_new(period_ms) {
    {
        _type: "Interval",
        period_ms: period_ms,
        last_tick: timestamp(),
        tick_count: 0
    }
}

// Ticks the interval. Returns true if the period has elapsed.
fn interval_tick(interval) {
    fn elapsed_ms() { elapsed(get(interval, "last_tick")) }
    if_then(elapsed_ms() >= get(interval, "period_ms"),
        fn() {
            {
                fired: true,
                interval: merge(interval, {
                    last_tick: timestamp(),
                    tick_count: get(interval, "tick_count") + 1
                })
            }
        },
        fn() { { fired: false, interval: interval } })
}

// Returns the tick count.
fn interval_count(interval) { get(interval, "tick_count") }

// Creates a timeout wrapper. If the work doesn't complete
// in time, returns an error result.
fn Timeout_new(work_fn, timeout_ms) {
    {
        _type: "Timeout",
        work: work_fn,
        timeout_ms: timeout_ms
    }
}

// Runs a function with a timeout. Returns Ok(result) or Err("timeout").
fn timeout_run(timeout) {
    fn start_time() { timestamp() }
    try_catch(
        fn() {
            fn result() { get(timeout, "work")() }
            if_then(elapsed(start_time()) > get(timeout, "timeout_ms"),
                fn() { Err("timeout") },
                fn() { Ok(result()) })
        },
        fn(e) { Err(to_string(e)) }
    )
}

// ── Stopwatch ───────────────────────────────────────────────────

// Creates a new stopwatch (not started).
fn Stopwatch_new() {
    { _type: "Stopwatch", start_time: nil, elapsed_ms: 0, running: false }
}

// Starts the stopwatch.
fn stopwatch_start(sw) {
    merge(sw, { start_time: timestamp(), running: true })
}

// Stops the stopwatch.
fn stopwatch_stop(sw) {
    if_then(get(sw, "running"),
        fn() {
            fn total() { get(sw, "elapsed_ms") + elapsed(get(sw, "start_time")) }
            merge(sw, { elapsed_ms: total(), running: false })
        },
        fn() { sw })
}

// Returns total elapsed milliseconds.
fn stopwatch_elapsed(sw) {
    if_then(get(sw, "running"),
        fn() { get(sw, "elapsed_ms") + elapsed(get(sw, "start_time")) },
        fn() { get(sw, "elapsed_ms") })
}

// Resets the stopwatch.
fn stopwatch_reset(sw) { Stopwatch_new() }

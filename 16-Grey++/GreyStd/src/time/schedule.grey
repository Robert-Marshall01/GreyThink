// GreyStd Time - Schedule
// Task scheduling and cron-like utilities

// Create a simple interval schedule
fn Schedule_interval(dur) {
  {
    _type: "Schedule",
    kind: "interval",
    interval_ms: duration_ms(dur),
    last_run: 0,
    run_count: 0
  }
}

// Create a one-shot schedule (runs once after delay)
fn Schedule_once(dur) {
  {
    _type: "Schedule",
    kind: "once",
    delay_ms: duration_ms(dur),
    created_at: timestamp(),
    fired: false
  }
}

// Create a fixed-count schedule
fn Schedule_repeat(dur, count) {
  {
    _type: "Schedule",
    kind: "repeat",
    interval_ms: duration_ms(dur),
    max_count: count,
    run_count: 0,
    last_run: 0
  }
}

// Check if a schedule should fire now
fn schedule_should_fire(sched) {
  fn kind() { get(sched, "kind") }
  cond(
    eq(kind(), "once"),
      and(not(get(sched, "fired")), gte(sub(timestamp(), get(sched, "created_at")), get(sched, "delay_ms"))),
    eq(kind(), "interval"),
      gte(sub(timestamp(), get(sched, "last_run")), get(sched, "interval_ms")),
    eq(kind(), "repeat"),
      and(lt(get(sched, "run_count"), get(sched, "max_count")),
          gte(sub(timestamp(), get(sched, "last_run")), get(sched, "interval_ms"))),
    false
  )
}

// Mark a schedule as fired (returns updated schedule)
fn schedule_fire(sched) {
  fn kind() { get(sched, "kind") }
  cond(
    eq(kind(), "once"), merge(sched, { fired: true }),
    eq(kind(), "interval"), merge(sched, { last_run: timestamp(), run_count: add(get(sched, "run_count"), 1) }),
    eq(kind(), "repeat"), merge(sched, { last_run: timestamp(), run_count: add(get(sched, "run_count"), 1) }),
    sched
  )
}

// Check if schedule is complete (no more firings)
fn schedule_is_done(sched) {
  fn kind() { get(sched, "kind") }
  cond(
    eq(kind(), "once"), get(sched, "fired"),
    eq(kind(), "repeat"), gte(get(sched, "run_count"), get(sched, "max_count")),
    false
  )
}

// Get remaining runs for repeat schedule
fn schedule_remaining(sched) {
  if_then(eq(get(sched, "kind"), "repeat"),
    fn() { sub(get(sched, "max_count"), get(sched, "run_count")) },
    fn() { nil }
  )
}

// Create a scheduled task (pairs schedule with action)
fn ScheduledTask_new(name, schedule, action) {
  {
    _type: "ScheduledTask",
    name: name,
    schedule: schedule,
    action: action,
    enabled: true
  }
}

// Tick a scheduled task (check and maybe run)
fn task_tick(st) {
  if_then(and(get(st, "enabled"), schedule_should_fire(get(st, "schedule"))),
    fn() {
      get(st, "action")()
      merge(st, { schedule: schedule_fire(get(st, "schedule")) })
    },
    fn() { st }
  )
}

// Enable/disable a scheduled task
fn task_enable(st) { merge(st, { enabled: true }) }
fn task_disable(st) { merge(st, { enabled: false }) }

// Check if task is still active
fn task_is_active(st) {
  and(get(st, "enabled"), not(schedule_is_done(get(st, "schedule"))))
}

// Create a simple task scheduler
fn Scheduler_new() {
  { _type: "Scheduler", tasks: [] }
}

// Add a task to the scheduler
fn scheduler_add(sched, task) {
  merge(sched, { tasks: append(get(sched, "tasks"), task) })
}

// Tick all tasks in the scheduler
fn scheduler_tick(sched) {
  merge(sched, { tasks: map(get(sched, "tasks"), fn(t) { task_tick(t) }) })
}

// Get active task count
fn scheduler_active_count(sched) {
  length(filter(get(sched, "tasks"), fn(t) { task_is_active(t) }))
}

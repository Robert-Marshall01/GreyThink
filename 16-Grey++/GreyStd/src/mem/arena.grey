// mem::arena â€” Region-based bump allocation
//
// In Grey++, an arena is a collection that holds objects and
// releases them all at once. Useful for managing groups of
// related temporary objects.

// Creates a new arena.
fn Arena_new() {
    { _type: "Arena", allocations: [], count: 0 }
}

// Creates an arena with a capacity hint.
fn Arena_with_capacity(cap) {
    { _type: "Arena", allocations: [], count: 0, capacity: cap }
}

// Allocates a value in the arena. Returns a handle.
fn arena_alloc(arena, value) {
    fn id() { get(arena, "count") }
    fn handle() { { _type: "ArenaHandle", id: id(), value: value } }
    fn new_arena() {
        merge(arena, {
            allocations: push(get(arena, "allocations"), handle()),
            count: id() + 1
        })
    }
    { arena: new_arena(), handle: handle() }
}

// Retrieves a value by handle.
fn arena_get(arena, handle) {
    fn id() { get(handle, "id") }
    fn allocs() { get(arena, "allocations") }
    if_then(id() >= 0,
        fn() { if_then(id() < len(allocs()),
            fn() { get(get(allocs(), id()), "value") },
            fn() { nil }) },
        fn() { nil })
}

// Returns the number of allocations.
fn arena_count(arena) { get(arena, "count") }

// Returns true if the arena is empty.
fn arena_is_empty(arena) { get(arena, "count") == 0 }

// Resets the arena, releasing all allocations.
fn arena_reset(arena) {
    merge(arena, { allocations: [], count: 0 })
}

// Iterates over all allocated values.
fn arena_for_each(arena, f) {
    forEach(get(arena, "allocations"), fn(alloc) {
        f(get(alloc, "value"))
    })
}

// Collects all allocated values into an array.
fn arena_to_array(arena) {
    map(get(arena, "allocations"), fn(alloc) { get(alloc, "value") })
}

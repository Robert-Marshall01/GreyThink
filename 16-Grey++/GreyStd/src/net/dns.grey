// net::dns — DNS resolution utilities
//
// Provides DNS lookup and caching abstractions.

// Performs a DNS lookup (simulated).
fn dns_lookup(hostname) {
    {
        _type: "DnsResult",
        hostname: hostname,
        addresses: [],
        ttl: 300,
        resolved_at: timestamp()
    }
}

// Creates a DNS cache.
fn DnsCache_new() {
    { _type: "DnsCache", entries: {}, max_size: 1000 }
}

// Looks up a hostname in the cache.
fn dns_cache_get(cache, hostname) {
    fn entries() { get(cache, "entries") }
    if_then(has_key(entries(), hostname),
        fn() {
            fn entry() { get(entries(), hostname) }
            fn age() { timestamp() - get(entry(), "resolved_at") }
            if_then(age() > get(entry(), "ttl") * 1000,
                fn() { None() },
                fn() { Some(entry()) })
        },
        fn() { None() })
}

// Stores a DNS result in the cache.
fn dns_cache_put(cache, result) {
    fn hostname() { get(result, "hostname") }
    set(cache, "entries", set(get(cache, "entries"), hostname(), result))
}

// Clears the DNS cache.
fn dns_cache_clear(cache) {
    set(cache, "entries", {})
}

// Returns the number of cached entries.
fn dns_cache_size(cache) {
    len(keys(get(cache, "entries")))
}

// ── URL Parsing ─────────────────────────────────────────────────

// Parses a URL string into components.
fn url_parse(url_string) {
    fn parse_protocol() {
        fn idx() { index_of(url_string, "://") }
        if_then(idx() >= 0,
            fn() { substr(url_string, 0, idx()) },
            fn() { "https" })
    }
    fn after_protocol() {
        fn idx() { index_of(url_string, "://") }
        if_then(idx() >= 0,
            fn() { substr(url_string, idx() + 3) },
            fn() { url_string })
    }
    fn parse_host() {
        fn rest() { after_protocol() }
        fn slash_idx() { index_of(rest(), "/") }
        fn query_idx() { index_of(rest(), "?") }
        fn end_idx() {
            cond(
                slash_idx() >= 0, slash_idx(),
                query_idx() >= 0, query_idx(),
                len(rest())
            )
        }
        substr(rest(), 0, end_idx())
    }
    fn parse_path() {
        fn rest() { after_protocol() }
        fn slash_idx() { index_of(rest(), "/") }
        if_then(slash_idx() < 0, fn() { "/" },
            fn() {
                fn query_idx() { index_of(rest(), "?") }
                if_then(query_idx() < 0,
                    fn() { substr(rest(), slash_idx()) },
                    fn() { substr(rest(), slash_idx(), query_idx() - slash_idx()) })
            })
    }
    fn parse_query() {
        fn q_idx() { index_of(url_string, "?") }
        fn h_idx() { index_of(url_string, "#") }
        if_then(q_idx() < 0, fn() { "" },
            fn() { if_then(h_idx() < 0,
                fn() { substr(url_string, q_idx() + 1) },
                fn() { substr(url_string, q_idx() + 1, h_idx() - q_idx() - 1) }) })
    }
    fn parse_fragment() {
        fn h_idx() { index_of(url_string, "#") }
        if_then(h_idx() < 0, fn() { "" },
            fn() { substr(url_string, h_idx() + 1) })
    }

    {
        _type: "Url",
        protocol: parse_protocol(),
        host: parse_host(),
        path: parse_path(),
        query: parse_query(),
        fragment: parse_fragment(),
        original: url_string
    }
}

// Reconstructs a URL from its components.
fn url_to_string(url) {
    fn base() { str(get(url, "protocol"), "://", get(url, "host"), get(url, "path")) }
    fn with_query() {
        if_then(len(get(url, "query")) > 0,
            fn() { str(base(), "?", get(url, "query")) },
            fn() { base() })
    }
    if_then(len(get(url, "fragment")) > 0,
        fn() { str(with_query(), "#", get(url, "fragment")) },
        fn() { with_query() })
}

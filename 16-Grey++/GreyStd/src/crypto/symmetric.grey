// GreyStd Crypto - Symmetric
// Symmetric encryption (AES-like) wrappers

// Create a symmetric cipher configuration
fn SymmetricCipher_new(algorithm, key) {
  {
    _type: "SymmetricCipher",
    algorithm: algorithm,
    key: key,
    mode: "CBC",
    padding: "PKCS7"
  }
}

// Create AES-256-CBC cipher
fn aes256_cbc(key) {
  SymmetricCipher_new("AES-256-CBC", key)
}

// Create AES-128-CBC cipher
fn aes128_cbc(key) {
  SymmetricCipher_new("AES-128-CBC", key)
}

// Set cipher mode
fn cipher_set_mode(cipher, mode) {
  merge(cipher, { mode: mode })
}

// Set cipher padding
fn cipher_set_padding(cipher, padding) {
  merge(cipher, { padding: padding })
}

// Encrypt plaintext with the cipher
fn cipher_encrypt(cipher, plaintext) {
  fn iv() { random_hex(16) }
  fn encrypted() { encrypt(plaintext, get(cipher, "key"), get(cipher, "algorithm")) }
  {
    _type: "CipherText",
    data: encrypted(),
    iv: iv(),
    algorithm: get(cipher, "algorithm")
  }
}

// Decrypt ciphertext with the cipher
fn cipher_decrypt(cipher, ciphertext) {
  decrypt(get(ciphertext, "data"), get(cipher, "key"), get(cipher, "algorithm"))
}

// Generate a random encryption key (hex string)
fn generate_key(bits) {
  fn byte_count() { div(bits, 8) }
  random_hex(byte_count())
}

// Generate a 256-bit key
fn generate_key_256() {
  generate_key(256)
}

// Generate a 128-bit key
fn generate_key_128() {
  generate_key(128)
}

// Simple XOR encryption (for lightweight use)
fn xor_encrypt(data, key) {
  fn data_bytes() { map(chars(data), fn(c) { char_code(c) }) }
  fn key_bytes() { map(chars(key), fn(c) { char_code(c) }) }
  fn encrypted_bytes() {
    map(enumerate(data_bytes()), fn(pair) {
      fn idx() { get(pair, 0) }
      fn byte() { get(pair, 1) }
      fn key_byte() { get(key_bytes(), mod(idx(), length(key_bytes()))) }
      bitxor(byte(), key_byte())
    })
  }
  map(encrypted_bytes(), fn(b) { to_hex_byte(b) })
}

// Convert byte to 2-char hex
fn to_hex_byte(b) {
  fn hex_chars() { "0123456789abcdef" }
  fn hi() { char_at(hex_chars(), div(b, 16)) }
  fn lo() { char_at(hex_chars(), mod(b, 16)) }
  concat_str(hi(), lo())
}

// Enumerate helper
fn enumerate(arr) {
  map(range(0, length(arr)), fn(i) { [i, get(arr, i)] })
}

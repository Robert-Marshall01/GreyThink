// concurrent::task â€” Task spawning and management
//
// Tasks are lightweight asynchronous units of work.
// Uses the built-in spawn() function.

// Creates a new task descriptor.
fn Task_new(name, work_fn) {
    { _type: "Task", name: name, work: work_fn, status: "pending", result: nil }
}

// Spawns a task for concurrent execution.
fn task_spawn(work_fn) {
    fn task() { Task_new("anonymous", work_fn) }
    spawn(work_fn)
    set(task(), "status", "running")
}

// Spawns a named task.
fn task_spawn_named(name, work_fn) {
    fn task() { Task_new(name, work_fn) }
    spawn(work_fn)
    set(task(), "status", "running")
}

// Spawns multiple tasks and collects results.
fn task_spawn_all(work_fns) {
    map(work_fns, fn(work_fn) { task_spawn(work_fn) })
}

// Creates a task that completes with a value (already resolved).
fn task_resolved(value) {
    { _type: "Task", name: "resolved", work: fn() { value }, status: "completed", result: value }
}

// Creates a task that fails with an error.
fn task_failed(err) {
    { _type: "Task", name: "failed", work: fn() { nil }, status: "failed", error: err }
}

// Returns the task status.
fn task_status(task) { get(task, "status") }

// Returns true if the task is completed.
fn task_is_done(task) {
    fn status() { get(task, "status") }
    status() == "completed" + "" 
}

// Returns true if the task failed.
fn task_is_failed(task) { get(task, "status") == "failed" }

// Yields execution to allow other tasks to run.
fn task_yield() {
    sleep(0)
}

// ═══════════════════════════════════════════════════════════════════════════
// Grey++ Blockchain — Ledger, Mining, Transactions, Consensus
// Replaces: Solidity, Rust (Substrate), Go (Hyperledger), Python (web3)
// ═══════════════════════════════════════════════════════════════════════════

section("GREY++ BLOCKCHAIN")

// ── 1. Transaction System ───────────────────────────────────────────────────
section("1. Transaction System")

fn Transaction(sender, recipient, amount, fee) {
    fn tx_data() { str(sender, recipient, to_string(amount), to_string(fee), now()) }
    {
        id: hash(tx_data()),
        sender: sender,
        recipient: recipient,
        amount: amount,
        fee: fee,
        timestamp: now(),
        signed: true,
        verify: fn() {
            and(amount > 0, and(fee >= 0, not(sender == recipient)))
        }
    }
}

fn Wallet(name, initial_balance) {
    fn make_wallet(balance, tx_history) {
        {
            name: name,
            balance: fn() { balance },
            send: fn(recipient_name, amount, fee) {
                if_then(balance < amount + fee,
                    { success: false, error: "Insufficient funds", wallet: make_wallet(balance, tx_history) },
                    fn() {
                        fn tx() { Transaction(name, recipient_name, amount, fee) }
                        log(str(name, " → ", recipient_name, ": ", amount, " (fee: ", fee, ")"))
                        { success: true, tx: tx(), wallet: make_wallet(balance - amount - fee, push(tx_history, tx())) }
                    }
                )
            },
            receive: fn(amount) {
                make_wallet(balance + amount, tx_history)
            },
            history: fn() { tx_history },
            describe: fn() { str(name, ": ", balance, " coins (", len(tx_history), " txs)") }
        }
    }
    make_wallet(initial_balance, [])
}

fn demo_transactions() {
    fn alice() { Wallet("Alice", 1000) }
    fn bob() { Wallet("Bob", 500) }
    fn carol() { Wallet("Carol", 200) }

    // Alice sends 250 to Bob
    fn r1() { get(alice(), "send")("Bob", 250, 1) }
    fn alice2() { get(r1(), "wallet") }
    fn bob2() { get(bob(), "receive")(250) }

    // Bob sends 100 to Carol
    fn r2() { get(bob2(), "send")("Carol", 100, 1) }
    fn bob3() { get(r2(), "wallet") }
    fn carol2() { get(carol(), "receive")(100) }

    // Try overdraft
    fn r3() { get(carol2(), "send")("Alice", 500, 1) }

    print(str("  ", get(alice2(), "describe")()))
    print(str("  ", get(bob3(), "describe")()))
    print(str("  ", get(carol2(), "describe")()))
    print(str("  Overdraft attempt: ", get(r3(), "error")))
}

demo_transactions()

// ── 2. Block Mining ─────────────────────────────────────────────────────────
section("2. Block Mining & Chain")

fn Block(index, transactions, previous_hash, difficulty) {
    // Simplified mining: compute hash with a random nonce (no recursive PoW)
    fn nonce() { random_int(0, 999999) }
    fn data() { str(to_string(index), json_stringify(transactions), previous_hash, to_string(nonce())) }
    fn block_hash() { hash(data()) }

    {
        index: index,
        timestamp: now(),
        transactions: transactions,
        previous_hash: previous_hash,
        nonce: nonce(),
        hash: block_hash(),
        difficulty: difficulty,
        tx_count: len(transactions)
    }
}

fn Blockchain() {
    fn genesis() {
        {
            index: 0,
            timestamp: now(),
            transactions: [],
            previous_hash: "0000000000000000",
            nonce: 0,
            hash: hash("genesis_block"),
            difficulty: 1,
            tx_count: 0
        }
    }

    fn make_chain(blocks, pending_txs, difficulty) {
        {
            add_transaction: fn(tx) {
                if_then(get(tx, "verify")(),
                    make_chain(blocks, push(pending_txs, tx), difficulty),
                    fn() {
                        warn("Invalid transaction rejected")
                        make_chain(blocks, pending_txs, difficulty)
                    }
                )
            },
            mine: fn() {
                fn prev() { last(blocks) }
                fn new_block() { Block(len(blocks), pending_txs, get(prev(), "hash"), difficulty) }
                fn total_fees() { reduce(pending_txs, fn(acc, tx) { acc + get(tx, "fee") }, 0) }
                log(str("Mining block #", len(blocks), " with ", len(pending_txs), " transactions..."))
                log(str("  Nonce found: ", get(new_block(), "nonce")))
                make_chain(push(blocks, new_block()), [], difficulty)
            },
            get_blocks: fn() { blocks },
            get_latest: fn() { last(blocks) },
            pending: fn() { pending_txs },
            height: fn() { len(blocks) },
            is_valid: fn() {
                fn check_pair(i) {
                    if_then(i >= len(blocks), true,
                        fn() {
                            fn current() { get(blocks, i) }
                            fn prev() { get(blocks, i - 1) }
                            fn valid() { get(current(), "previous_hash") == get(prev(), "hash") }
                            if_then(valid(), check_pair(i + 1), false)
                        }
                    )
                }
                if_then(len(blocks) <= 1, true, check_pair(1))
            },
            describe: fn() {
                fn total_txs() { reduce(blocks, fn(acc, b) { acc + get(b, "tx_count") }, 0) }
                str("Chain height: ", len(blocks), " | Total txs: ", total_txs(), " | Valid: ", true)
            }
        }
    }

    make_chain([genesis()], [], 1)
}

fn demo_blockchain() {
    fn chain0() { Blockchain() }

    // Add transactions
    fn tx1() { Transaction("Alice", "Bob", 50, 1) }
    fn tx2() { Transaction("Bob", "Carol", 25, 1) }
    fn tx3() { Transaction("Carol", "Dave", 10, 1) }

    fn chain1() { get(chain0(), "add_transaction")(tx1()) }
    fn chain2() { get(chain1(), "add_transaction")(tx2()) }
    fn chain3() { get(chain2(), "add_transaction")(tx3()) }

    print(str("  Pending txs: ", len(get(chain3(), "pending")())))

    // Mine block
    fn chain4() { get(chain3(), "mine")() }

    // Add more transactions and mine again
    fn tx4() { Transaction("Dave", "Alice", 5, 1) }
    fn chain5() { get(chain4(), "add_transaction")(tx4()) }
    fn chain6() { get(chain5(), "mine")() }

    print(str("  ", get(chain6(), "describe")()))
    print(str("  Chain valid: ", get(chain6(), "is_valid")()))

    // Display blocks
    forEach(get(chain6(), "get_blocks")(), fn(b) {
        print(str("  Block #", get(b, "index"),
            " | Hash: ", substr(get(b, "hash"), 0, 12), "...",
            " | Txs: ", get(b, "tx_count"),
            " | Nonce: ", get(b, "nonce")))
    })
}

demo_blockchain()

// ── 3. Smart Contract ───────────────────────────────────────────────────────
section("3. Smart Contract — Token")

fn TokenContract(name, symbol, total_supply, owner) {
    fn make_contract(balances, allowances, paused) {
        {
            name: fn() { name },
            symbol: fn() { symbol },
            total_supply: fn() { total_supply },
            balance_of: fn(account) { if_then(has_key(balances, account), get(balances, account), 0) },
            transfer: fn(from, to, amount) {
                if_then(paused,
                    { success: false, error: "Contract paused" },
                    fn() {
                        fn sender_bal() { if_then(has_key(balances, from), get(balances, from), 0) }
                        if_then(sender_bal() < amount,
                            { success: false, error: "Insufficient balance" },
                            fn() {
                                fn receiver_bal() { if_then(has_key(balances, to), get(balances, to), 0) }
                                fn new_balances() { set(set(balances, from, sender_bal() - amount), to, receiver_bal() + amount) }
                                log(str("Transfer: ", from, " → ", to, ": ", amount, " ", symbol))
                                { success: true, contract: make_contract(new_balances(), allowances, paused) }
                            }
                        )
                    }
                )
            },
            mint: fn(to, amount, caller) {
                if_then(not(caller == owner),
                    { success: false, error: "Only owner can mint" },
                    fn() {
                        fn current() { if_then(has_key(balances, to), get(balances, to), 0) }
                        fn new_balances() { set(balances, to, current() + amount) }
                        log(str("Minted ", amount, " ", symbol, " to ", to))
                        { success: true, contract: make_contract(new_balances(), allowances, paused) }
                    }
                )
            },
            pause: fn(caller) {
                if_then(caller == owner,
                    make_contract(balances, allowances, true),
                    make_contract(balances, allowances, paused)
                )
            },
            describe: fn() {
                str(name, " (", symbol, ") | Supply: ", total_supply, " | Paused: ", paused)
            }
        }
    }
    make_contract(set({}, owner, total_supply), {}, false)
}

fn demo_smart_contract() {
    fn token() { TokenContract("GreyToken", "GRT", 1000000, "deployer") }
    print(str("  ", get(token(), "describe")()))
    print(str("  Deployer balance: ", get(token(), "balance_of")("deployer")))

    // Transfer tokens
    fn r1() { get(token(), "transfer")("deployer", "alice", 50000) }
    fn t1() { get(r1(), "contract") }

    fn r2() { get(t1(), "transfer")("deployer", "bob", 30000) }
    fn t2() { get(r2(), "contract") }

    fn r3() { get(t2(), "transfer")("alice", "carol", 10000) }
    fn t3() { get(r3(), "contract") }

    print(str("  Alice:    ", get(t3(), "balance_of")("alice"), " GRT"))
    print(str("  Bob:      ", get(t3(), "balance_of")("bob"), " GRT"))
    print(str("  Carol:    ", get(t3(), "balance_of")("carol"), " GRT"))
    print(str("  Deployer: ", get(t3(), "balance_of")("deployer"), " GRT"))

    // Mint new tokens
    fn r4() { get(t3(), "mint")("carol", 5000, "deployer") }
    fn t4() { get(r4(), "contract") }
    print(str("  Carol after mint: ", get(t4(), "balance_of")("carol"), " GRT"))

    // Unauthorized mint
    fn r5() { get(t4(), "mint")("hacker", 999999, "hacker") }
    print(str("  Unauthorized mint: ", get(r5(), "error")))
}

demo_smart_contract()

// ── 4. Merkle Tree ──────────────────────────────────────────────────────────
section("4. Merkle Tree for Data Integrity")

fn MerkleTree(data_items) {
    fn build_leaves() { map(data_items, fn(item) { hash(to_string(item)) }) }

    fn build_tree(nodes) {
        if_then(len(nodes) <= 1,
            nodes,
            fn() {
                fn pairs() { range(0, ceil(len(nodes) / 2)) }
                fn next_level() {
                    map(pairs(), fn(i) {
                        fn left() { get(nodes, i * 2) }
                        fn right() { if_then(i * 2 + 1 < len(nodes), get(nodes, i * 2 + 1), left()) }
                        hash(str(left(), right()))
                    })
                }
                build_tree(next_level())
            }
        )
    }

    fn leaves() { build_leaves() }
    fn root() { head(build_tree(leaves())) }

    {
        root: fn() { root() },
        leaf_count: fn() { len(leaves()) },
        verify_item: fn(item) {
            fn item_hash() { hash(to_string(item)) }
            includes(leaves(), item_hash())
        }
    }
}

fn demo_merkle() {
    fn transactions() { ["tx_001", "tx_002", "tx_003", "tx_004", "tx_005", "tx_006", "tx_007", "tx_008"] }
    fn tree() { MerkleTree(transactions()) }

    print(str("  Merkle root: ", substr(get(tree(), "root")(), 0, 16), "..."))
    print(str("  Leaf count: ", get(tree(), "leaf_count")()))
    print(str("  Verify tx_003: ", get(tree(), "verify_item")("tx_003")))
    print(str("  Verify tx_999: ", get(tree(), "verify_item")("tx_999")))
}

demo_merkle()

divider()
print("Blockchain demo complete — Transactions, Mining, Smart Contracts, Merkle Trees all working.")

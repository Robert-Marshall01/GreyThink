// core::string — String utilities
//
// Grey++ strings are primitive values (like JavaScript strings).
// This module provides additional string utility functions that
// complement the built-in string operations:
//   split, join, trim, upper, lower, replace, contains,
//   starts_with, ends_with, char_at, substr, pad_start, pad_end,
//   repeat_str, includes, template, str

// ── String Construction ─────────────────────────────────────────

// Creates an empty string.
fn string_new() { "" }

// Creates a string from a value.
fn string_from(value) { to_string(value) }

// Creates a string of n copies of ch.
fn string_repeat(ch, n) { repeat_str(to_string(ch), n) }

// Creates a string from an array of char codes.
fn string_from_codes(codes) {
    join(map(codes, fn(code) { char_at(to_string(code), 0) }), "")
}

// ── String Inspection ───────────────────────────────────────────

// Returns the byte length of a string.
fn string_len(s) { len(s) }

// Returns true if the string is empty.
fn string_is_empty(s) { len(s) == 0 }

// Returns the character at index i.
fn string_char_at(s, i) { char_at(s, i) }

// Returns an array of individual characters.
fn string_chars(s) {
    fn collect(i, acc) {
        if_then(i >= len(s),
            fn() { acc },
            fn() { collect(i + 1, push(acc, char_at(s, i))) })
    }
    collect(0, [])
}

// Returns the number of characters.
fn string_char_count(s) { len(string_chars(s)) }

// ── String Searching ────────────────────────────────────────────

// Returns true if s contains the substring pattern.
fn string_contains(s, pattern) { includes(s, pattern) }

// Returns the index of the first occurrence of pattern, or -1.
fn string_find(s, pattern) { index_of(s, pattern) }

// Returns true if s starts with prefix.
fn string_starts_with(s, prefix) { starts_with(s, prefix) }

// Returns true if s ends with suffix.
fn string_ends_with(s, suffix) { ends_with(s, suffix) }

// Counts non-overlapping occurrences of pattern in s.
fn string_count(s, pattern) {
    fn count_from(start, acc) {
        fn rest() { substr(s, start, len(s) - start) }
        fn idx() { index_of(rest(), pattern) }
        if_then(idx() < 0,
            fn() { acc },
            fn() { count_from(start + idx() + len(pattern), acc + 1) })
    }
    count_from(0, 0)
}

// ── String Transformation ───────────────────────────────────────

// Returns the string in uppercase.
fn string_upper(s) { upper(s) }

// Returns the string in lowercase.
fn string_lower(s) { lower(s) }

// Strips leading and trailing whitespace.
fn string_trim(s) { trim(s) }

// Strips leading whitespace.
fn string_trim_start(s) {
    fn find_start(i) {
        if_then(i >= len(s), fn() { i },
            fn() {
                fn ch() { char_at(s, i) }
                if_then(ch() == " " + "" , fn() { find_start(i + 1) },
                    fn() { i })
            })
    }
    substr(s, find_start(0))
}

// Strips trailing whitespace.
fn string_trim_end(s) {
    fn find_end(i) {
        if_then(i <= 0, fn() { 0 },
            fn() {
                fn ch() { char_at(s, i - 1) }
                if_then(ch() == " " + "", fn() { find_end(i - 1) },
                    fn() { i })
            })
    }
    substr(s, 0, find_end(len(s)))
}

// Replaces all occurrences of `from_str` with `to_str`.
fn string_replace_all(s, from_str, to_str) {
    join(split(s, from_str), to_str)
}

// Replaces the first occurrence of `from_str` with `to_str`.
fn string_replace_first(s, from_str, to_str) {
    replace(s, from_str, to_str)
}

// Reverses the string.
fn string_reverse(s) {
    join(reverse(string_chars(s)), "")
}

// Capitalizes the first character.
fn string_capitalize(s) {
    if_then(string_is_empty(s), "",
        fn() { str(upper(char_at(s, 0)), substr(s, 1)) })
}

// Converts to title case (capitalize each word).
fn string_title(s) {
    join(map(split(s, " "), fn(word) { string_capitalize(word) }), " ")
}

// ── String Splitting & Joining ──────────────────────────────────

// Splits a string by delimiter.
fn string_split(s, delimiter) { split(s, delimiter) }

// Joins an array with separator.
fn string_join(arr, separator) { join(arr, separator) }

// Splits a string into lines.
fn string_lines(s) { split(s, "\n") }

// Splits a string into words (by whitespace).
fn string_words(s) {
    filter(split(s, " "), fn(w) { len(w) > 0 })
}

// ── String Padding & Alignment ──────────────────────────────────

// Pads from the left to reach width n.
fn string_pad_start(s, n, ch) { pad_start(s, n, ch) }

// Pads from the right to reach width n.
fn string_pad_end(s, n, ch) { pad_end(s, n, ch) }

// Centers the string within width n.
fn string_center(s, n, ch) {
    fn deficit() { max(0, n - len(s)) }
    fn left_pad() { floor(deficit() / 2) }
    fn right_pad() { deficit() - left_pad() }
    str(repeat_str(ch, left_pad()), s, repeat_str(ch, right_pad()))
}

// ── String Extraction ───────────────────────────────────────────

// Returns a substring.
fn string_substr(s, start, length) { substr(s, start, length) }

// Returns a slice by start and end index.
fn string_slice(s, start, end) { substr(s, start, end - start) }

// ── StringBuilder ───────────────────────────────────────────────

// Creates a new string builder (accumulates parts efficiently).
fn StringBuilder_new() {
    { _type: "StringBuilder", parts: [] }
}

// Appends a string to the builder.
fn sb_push(builder, s) {
    set(builder, "parts", push(get(builder, "parts"), to_string(s)))
}

// Appends a string followed by a newline.
fn sb_push_line(builder, s) {
    sb_push(builder, str(s, "\n"))
}

// Returns the current length.
fn sb_len(builder) {
    reduce(get(builder, "parts"), fn(acc, part) { acc + len(part) }, 0)
}

// Builds the final string.
fn sb_build(builder) {
    join(get(builder, "parts"), "")
}

// Clears the builder.
fn sb_clear(builder) {
    set(builder, "parts", [])
}

// ── Formatting ──────────────────────────────────────────────────

// Formats a template string with positional arguments.
// Uses {0}, {1}, etc. for substitution.
fn string_format(tmpl, args) {
    template(tmpl, args)
}

// Formats a value for display.
fn display(value) { to_string(value) }

// Formats a value for debug output (with type info).
fn debug_format(value) {
    str("[", type_of(value), "] ", to_string(value))
}

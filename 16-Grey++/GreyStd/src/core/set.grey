// core::set — Hash set utilities
//
// In Grey++, sets are represented as objects where keys are the
// set elements and values are true. This module provides
// set operations like union, intersection, and difference.

// ── Set Construction ────────────────────────────────────────────

// Creates an empty set.
fn set_new() { { _type: "Set", items: {} } }

// Creates a set from an array of values.
fn set_from(arr) {
    fn build(i, items) {
        if_then(i >= len(arr),
            fn() { { _type: "Set", items: items } },
            fn() { build(i + 1, set(items, to_string(get(arr, i)), true)) })
    }
    build(0, {})
}

// ── Set Inspection ──────────────────────────────────────────────

// Returns the number of elements.
fn set_len(s) { len(keys(get(s, "items"))) }

// Returns true if the set is empty.
fn set_is_empty(s) { set_len(s) == 0 }

// Returns true if the set contains value.
fn set_contains(s, value) { has_key(get(s, "items"), to_string(value)) }

// Returns the elements as an array.
fn set_to_array(s) { keys(get(s, "items")) }

// ── Set Modification ────────────────────────────────────────────

// Adds a value to the set (non-mutating).
fn set_add(s, value) {
    { _type: "Set", items: set(get(s, "items"), to_string(value), true) }
}

// Removes a value from the set (non-mutating).
fn set_remove(s, value) {
    { _type: "Set", items: omit(get(s, "items"), to_string(value)) }
}

// Clears the set.
fn set_clear(s) { set_new() }

// ── Set Operations ──────────────────────────────────────────────

// Returns the union of two sets.
fn set_union(a, b) {
    { _type: "Set", items: merge(get(a, "items"), get(b, "items")) }
}

// Returns the intersection of two sets.
fn set_intersection(a, b) {
    fn items_a() { get(a, "items") }
    fn items_b() { get(b, "items") }
    fn common() {
        filter(keys(items_a()), fn(k) { has_key(items_b(), k) })
    }
    set_from(common())
}

// Returns the difference (a - b).
fn set_difference(a, b) {
    fn items_a() { get(a, "items") }
    fn items_b() { get(b, "items") }
    fn only_a() {
        filter(keys(items_a()), fn(k) { not(has_key(items_b(), k)) })
    }
    set_from(only_a())
}

// Returns the symmetric difference (elements in either but not both).
fn set_symmetric_difference(a, b) {
    set_union(set_difference(a, b), set_difference(b, a))
}

// Returns true if a is a subset of b.
fn set_is_subset(a, b) {
    every(set_to_array(a), fn(item) { set_contains(b, item) })
}

// Returns true if a is a superset of b.
fn set_is_superset(a, b) { set_is_subset(b, a) }

// Returns true if two sets have no elements in common.
fn set_is_disjoint(a, b) {
    not(some(set_to_array(a), fn(item) { set_contains(b, item) }))
}

// ── Set Iteration ───────────────────────────────────────────────

// Iterates over each element.
fn set_for_each(s, f) {
    forEach(set_to_array(s), f)
}

// Maps set elements through a function, returning a new set.
fn set_map(s, f) {
    set_from(map(set_to_array(s), f))
}

// Filters set elements by predicate.
fn set_filter(s, predicate) {
    set_from(filter(set_to_array(s), predicate))
}

// Reduces set elements.
fn set_reduce(s, f, init) {
    reduce(set_to_array(s), f, init)
}

// Returns true if any element matches.
fn set_any(s, predicate) {
    some(set_to_array(s), predicate)
}

// Returns true if all elements match.
fn set_all(s, predicate) {
    every(set_to_array(s), predicate)
}

// core::vec — Dynamic array (vector) utilities
//
// In Grey++, arrays are already dynamic. This module provides
// higher-level vector operations including construction patterns,
// searching, sorting, and functional transformations.

// ── Vector Construction ─────────────────────────────────────────

// Creates a new empty vector.
fn vec_new() { [] }

// Creates a vector with n copies of value.
fn vec_filled(value, n) { repeat(n, fn(i) { value }) }

// Creates a vector from an iterator (array).
fn vec_from(arr) { map(arr, fn(x) { x }) }

// Creates a vector from a range.
fn vec_range(start, end) { range(start, end) }

// ── Vector Operations ───────────────────────────────────────────

// Returns the length.
fn vec_len(v) { len(v) }

// Returns true if empty.
fn vec_is_empty(v) { len(v) == 0 }

// Returns the element at index.
fn vec_get(v, index) { get(v, index) }

// Returns the first element.
fn vec_first(v) { head(v) }

// Returns the last element.
fn vec_last(v) { last(v) }

// Appends a value (non-mutating).
fn vec_push(v, value) { push(v, value) }

// Removes and returns the last element as { value, vec }.
fn vec_pop(v) {
    if_then(vec_is_empty(v),
        fn() { { value: nil, vec: v } },
        fn() { { value: last(v), vec: take(v, len(v) - 1) } })
}

// Inserts a value at index (non-mutating).
fn vec_insert(v, index, value) {
    concat(concat(take(v, index), [value]), drop(v, index))
}

// Removes the element at index (non-mutating).
fn vec_remove(v, index) {
    concat(take(v, index), drop(v, index + 1))
}

// Sets the element at index (non-mutating).
fn vec_set(v, index, value) {
    map(range(0, len(v)), fn(i) {
        if_then(i == index, value, fn() { get(v, i) })
    })
}

// Swaps two elements at indices a and b (non-mutating).
fn vec_swap(v, a, b) {
    map(range(0, len(v)), fn(i) {
        cond(
            i == a, get(v, b),
            i == b, get(v, a),
            get(v, i)
        )
    })
}

// ── Vector Search ───────────────────────────────────────────────

// Returns true if the vector contains value.
fn vec_contains(v, value) { includes(v, value) }

// Returns the index of value, or -1.
fn vec_index_of(v, value) { index_of(v, value) }

// Binary search on a sorted vector. Returns index or -1.
fn vec_binary_search(v, target) {
    fn search(lo, hi) {
        if_then(lo >= hi, fn() { -1 },
            fn() {
                fn mid() { lo + floor((hi - lo) / 2) }
                fn val() { get(v, mid()) }
                cond(
                    val() == target, mid(),
                    val() < target,  fn() { search(mid() + 1, hi) },
                    fn() { search(lo, mid()) }
                )
            })
    }
    search(0, len(v))
}

// ── Vector Transformation ───────────────────────────────────────

// Maps each element.
fn vec_map(v, f) { map(v, f) }

// Filters elements.
fn vec_filter(v, predicate) { filter(v, predicate) }

// Reduces to a single value.
fn vec_reduce(v, f, init) { reduce(v, f, init) }

// Sorts the vector.
fn vec_sort(v, comparator) { sort(v, comparator) }

// Sorts by a key function.
fn vec_sort_by_key(v, key_fn) {
    sort(v, fn(a, b) { key_fn(a) - key_fn(b) })
}

// Reverses the vector.
fn vec_reverse(v) { reverse(v) }

// Removes consecutive duplicates.
fn vec_dedup(v) {
    if_then(vec_is_empty(v), fn() { [] },
        fn() {
            reduce(tail(v), fn(acc, item) {
                if_then(last(acc) == item, fn() { acc },
                    fn() { push(acc, item) })
            }, [head(v)])
        })
}

// Retains only elements for which predicate returns true.
fn vec_retain(v, predicate) { filter(v, predicate) }

// Drains a range, returning { drained, remaining }.
fn vec_drain(v, start, end) {
    {
        drained: slice(v, start, end),
        remaining: concat(take(v, start), drop(v, end))
    }
}

// Extends a vector with another.
fn vec_extend(v, other) { concat(v, other) }

// Flattens one level.
fn vec_flatten(v) { flat(v) }

// Maps then flattens.
fn vec_flat_map(v, f) { flat_map(v, f) }

// ── Vector Slicing ──────────────────────────────────────────────

// Returns a sub-vector.
fn vec_slice(v, start, end) { slice(v, start, end) }

// Returns first n elements.
fn vec_take(v, n) { take(v, n) }

// Drops first n elements.
fn vec_drop(v, n) { drop(v, n) }

// Chunks the vector into sub-vectors of given size.
fn vec_chunk(v, size) { chunk(v, size) }

// Sliding windows.
fn vec_windows(v, size) {
    if_then(size > len(v), fn() { [] },
        fn() { map(range(0, len(v) - size + 1), fn(i) {
            slice(v, i, i + size)
        }) })
}

// ── Vector Aggregation ──────────────────────────────────────────

// Returns the sum of numeric elements.
fn vec_sum(v) { sum(v) }

// Returns the average of numeric elements.
fn vec_avg(v) { avg(v) }

// Returns the minimum element.
fn vec_min(v) { reduce(tail(v), fn(a, b) { min(a, b) }, head(v)) }

// Returns the maximum element.
fn vec_max(v) { reduce(tail(v), fn(a, b) { max(a, b) }, head(v)) }

// Folds all elements.
fn vec_fold(v, init, f) { reduce(v, f, init) }

// Partitions into passing and failing.
fn vec_partition(v, predicate) {
    {
        pass: filter(v, predicate),
        fail: filter(v, fn(x) { not(predicate(x)) })
    }
}

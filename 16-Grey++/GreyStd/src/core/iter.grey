// core::iter — Iterator protocol and adapters
//
// In Grey++, iterators are objects with a next() function that
// returns either Some(value) or None(). This module provides
// iterator construction, lazy adapters, and eager consumers.
//
// Iterator protocol:
//   { _type: "Iterator", next: fn() { Some(value) | None() } }

// ── Iterator Construction ───────────────────────────────────────

// Creates an iterator from an array.
fn iter_from(arr) {
    fn state() { { pos: 0 } }
    {
        _type: "Iterator",
        next: fn() {
            fn pos() { get(state(), "pos") }
            if_then(pos() >= len(arr), fn() { None() },
                fn() {
                    fn val() { get(arr, pos()) }
                    set(state(), "pos", pos() + 1)
                    Some(val())
                })
        }
    }
}

// Creates an empty iterator.
fn iter_empty() {
    { _type: "Iterator", next: fn() { None() } }
}

// Creates an iterator that yields a single value.
fn iter_once(value) {
    fn done() { { yielded: false } }
    {
        _type: "Iterator",
        next: fn() {
            if_then(get(done(), "yielded"), fn() { None() },
                fn() {
                    set(done(), "yielded", true)
                    Some(value)
                })
        }
    }
}

// Creates an iterator from a range [start, end).
fn iter_range(start, end) { iter_from(range(start, end)) }

// Creates an infinite iterator from a function.
fn iter_from_fn(f) {
    { _type: "Iterator", next: f }
}

// Creates an iterator of successive values: first, f(first), f(f(first)), ...
fn iter_successors(first, f) {
    fn state() { { current: first, started: false } }
    {
        _type: "Iterator",
        next: fn() {
            if_then(not(get(state(), "started")),
                fn() {
                    set(state(), "started", true)
                    Some(first)
                },
                fn() {
                    fn next_val() { f(get(state(), "current")) }
                    if_then(is_nil(next_val()), fn() { None() },
                        fn() {
                            set(state(), "current", next_val())
                            Some(next_val())
                        })
                })
        }
    }
}

// ── Eager Consumers ─────────────────────────────────────────────
// These operate on arrays directly (Grey++ arrays are the primary
// iterable type). Use the built-in functions for lazy evaluation.

// Collects an iterator into an array.
// Since Grey++ iterators are complex, prefer using arrays directly.
fn iter_collect(arr) { map(arr, fn(x) { x }) }

// Folds array elements into a single value.
fn iter_fold(arr, init, f) { reduce(arr, f, init) }

// Reduces without initial value.
fn iter_reduce_no_init(arr, f) {
    if_then(len(arr) == 0, fn() { nil },
        fn() { reduce(tail(arr), f, head(arr)) })
}

// Counts elements.
fn iter_count(arr) { len(arr) }

// Returns the last element.
fn iter_last(arr) { last(arr) }

// Returns the first matching element.
fn iter_find(arr, predicate) { find(arr, predicate) }

// Returns the index of the first match.
fn iter_position(arr, predicate) {
    fn search(i) {
        if_then(i >= len(arr), fn() { -1 },
            fn() { if_then(predicate(get(arr, i)), fn() { i },
                fn() { search(i + 1) }) })
    }
    search(0)
}

// Returns true if any element matches.
fn iter_any(arr, predicate) { some(arr, predicate) }

// Returns true if all elements match.
fn iter_all(arr, predicate) { every(arr, predicate) }

// Returns the sum of numeric elements.
fn iter_sum(arr) { sum(arr) }

// Returns the product of numeric elements.
fn iter_product(arr) { reduce(arr, fn(acc, x) { acc * x }, 1) }

// Returns the minimum.
fn iter_min(arr) {
    if_then(len(arr) == 0, fn() { nil },
        fn() { reduce(tail(arr), fn(a, b) { min(a, b) }, head(arr)) })
}

// Returns the maximum.
fn iter_max(arr) {
    if_then(len(arr) == 0, fn() { nil },
        fn() { reduce(tail(arr), fn(a, b) { max(a, b) }, head(arr)) })
}

// Partitions into two arrays based on predicate.
fn iter_partition(arr, predicate) {
    {
        pass: filter(arr, predicate),
        fail: filter(arr, fn(x) { not(predicate(x)) })
    }
}

// Unzips an array of pairs into two arrays.
fn iter_unzip(pairs) {
    {
        first: map(pairs, fn(p) { get(p, 0) }),
        second: map(pairs, fn(p) { get(p, 1) })
    }
}

// ── Lazy Adapters (as array transformations) ────────────────────

// Maps each element.
fn iter_map(arr, f) { map(arr, f) }

// Filters elements.
fn iter_filter(arr, predicate) { filter(arr, predicate) }

// Maps then flattens.
fn iter_flat_map(arr, f) { flat_map(arr, f) }

// Flattens nested arrays.
fn iter_flatten(arr) { flatten(arr) }

// Takes the first n elements.
fn iter_take(arr, n) { take(arr, n) }

// Skips the first n elements.
fn iter_skip(arr, n) { drop(arr, n) }

// Takes while predicate holds.
fn iter_take_while(arr, predicate) {
    fn collect(i, acc) {
        if_then(i >= len(arr), fn() { acc },
            fn() {
                fn item() { get(arr, i) }
                if_then(predicate(item()),
                    fn() { collect(i + 1, push(acc, item())) },
                    fn() { acc })
            })
    }
    collect(0, [])
}

// Skips while predicate holds.
fn iter_skip_while(arr, predicate) {
    fn find_start(i) {
        if_then(i >= len(arr), fn() { i },
            fn() { if_then(predicate(get(arr, i)),
                fn() { find_start(i + 1) }, fn() { i }) })
    }
    drop(arr, find_start(0))
}

// Chains two arrays.
fn iter_chain(a, b) { concat(a, b) }

// Zips two arrays into pairs.
fn iter_zip(a, b) { zip(a, b) }

// Attaches index to each element.
fn iter_enumerate(arr) {
    map(range(0, len(arr)), fn(i) { [i, get(arr, i)] })
}

// Inserts separator between elements.
fn iter_intersperse(arr, sep) {
    if_then(len(arr) <= 1, fn() { arr },
        fn() {
            fn build(i, acc) {
                if_then(i >= len(arr), fn() { acc },
                    fn() { build(i + 1, push(push(acc, sep), get(arr, i))) })
            }
            build(1, [head(arr)])
        })
}

// Takes every nth element.
fn iter_step_by(arr, n) {
    filter(iter_enumerate(arr), fn(pair) { mod(get(pair, 0), n) == 0 })
}

// Removes consecutive duplicates.
fn iter_dedup(arr) {
    if_then(len(arr) == 0, fn() { [] },
        fn() {
            reduce(tail(arr), fn(acc, item) {
                if_then(last(acc) == item, fn() { acc },
                    fn() { push(acc, item) })
            }, [head(arr)])
        })
}

// Side-effect inspection without modifying elements.
fn iter_inspect(arr, f) {
    forEach(arr, f)
    arr
}

// Executes fn for each element.
fn iter_for_each(arr, f) { forEach(arr, f) }

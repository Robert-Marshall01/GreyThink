// GreyStd Serial - JSON
// JSON serialization and deserialization utilities

// Parse a JSON string into a value
fn json_parse(text) {
  json_decode(text)
}

// Serialize a value to a JSON string
fn json_serialize(value) {
  json_encode(value)
}

// Serialize with pretty printing
fn json_pretty(value) {
  json_encode(value, { indent: 2 })
}

// Serialize with custom indent
fn json_pretty_indent(value, spaces) {
  json_encode(value, { indent: spaces })
}

// Safely parse JSON, returning a Result
fn json_try_parse(text) {
  fn result() { json_decode(text) }
  try_catch(result, fn(err) { Err(err) }, fn(val) { Ok(val) })
}

// Get a nested value by dot-separated path
fn json_get_path(obj, path) {
  fn parts() { split(path, ".") }
  fold(parts(), obj, fn(current, key) {
    if_then(eq(current, nil), fn() { nil }, fn() {
      get(current, key)
    })
  })
}

// Set a nested value by key path (returns new object)
fn json_set_path(obj, path, value) {
  fn parts() { split(path, ".") }
  fn set_recursive(current, keys, val) {
    fn key() { get(keys, 0) }
    fn rest() { slice(keys, 1) }
    if_then(eq(length(keys), 1),
      fn() { merge(current, fromEntries([[key(), val]])) },
      fn() {
        fn child() { if_then(eq(get(current, key()), nil), fn() { {} }, fn() { get(current, key()) }) }
        merge(current, fromEntries([[key(), set_recursive(child(), rest(), val)]]))
      }
    )
  }
  set_recursive(obj, parts(), value)
}

// Merge two JSON objects deeply
fn json_merge_deep(a, b) {
  fn b_keys() { keys(b) }
  fold(b_keys(), a, fn(result, key) {
    fn a_val() { get(a, key) }
    fn b_val() { get(b, key) }
    if_then(and(is_object(a_val()), is_object(b_val())),
      fn() { merge(result, fromEntries([[key, json_merge_deep(a_val(), b_val())]])) },
      fn() { merge(result, fromEntries([[key, b_val()]])) }
    )
  })
}

// Check if a string is valid JSON
fn json_is_valid(text) {
  fn try_parse() { json_decode(text) }
  try_catch(try_parse, fn(_) { false }, fn(_) { true })
}

// Create a JSON patch (list of differences)
fn json_diff(a, b) {
  fn all_keys() { unique(concat(keys(a), keys(b))) }
  filter(map(all_keys(), fn(key) {
    fn av() { get(a, key) }
    fn bv() { get(b, key) }
    cond(
      eq(av(), nil), { op: "add", key: key, value: bv() },
      eq(bv(), nil), { op: "remove", key: key, value: av() },
      not(eq(av(), bv())), { op: "change", key: key, from: av(), to: bv() },
      nil
    )
  }), fn(x) { not(eq(x, nil)) })
}

// Flatten a nested object into dot-notation keys
fn json_flatten(obj) {
  fn flatten_rec(current, prefix) {
    fn k() { keys(current) }
    fold(k(), {}, fn(result, key) {
      fn full_key() { if_then(eq(prefix, ""), fn() { key }, fn() { concat_str(prefix, ".", key) }) }
      fn val() { get(current, key) }
      if_then(is_object(val()),
        fn() { merge(result, flatten_rec(val(), full_key())) },
        fn() { merge(result, fromEntries([[full_key(), val()]])) }
      )
    })
  }
  flatten_rec(obj, "")
}

// Unflatten dot-notation keys back into nested object
fn json_unflatten(flat) {
  fold(keys(flat), {}, fn(result, key) {
    json_set_path(result, key, get(flat, key))
  })
}

/// deterministic::collections — Ordered, deterministic collection types.
///
/// These collections guarantee iteration order is always the same for the
/// same sequence of operations, regardless of platform, architecture, or
/// hash seed. Suitable for consensus, snapshot hashing, and reproducible tests.

use crate::core::string::String;
use crate::core::vec::Vec;
use crate::core::option::Option;
use crate::core::iter::Iterator;

// ─── OrderedMap ───────────────────────────────────────────────────────────────

/// A map that preserves insertion order deterministically.
///
/// Internally backed by a Vec of key-value pairs with a sorted index for
/// O(log n) lookup. Iteration is always in insertion order.
pub struct OrderedMap<K: Ord + Eq, V> {
    entries: Vec<(K, V)>,
    /// Sorted indices into `entries` for binary-search lookup.
    sorted_idx: Vec<usize>,
}

impl<K: Ord + Eq + Clone, V> OrderedMap<K, V> {
    pub fn new() -> OrderedMap<K, V> {
        OrderedMap { entries: Vec::new(), sorted_idx: Vec::new() }
    }

    pub fn with_capacity(cap: usize) -> OrderedMap<K, V> {
        OrderedMap { entries: Vec::with_capacity(cap), sorted_idx: Vec::with_capacity(cap) }
    }

    pub fn len(&self) -> usize { self.entries.len() }
    pub fn is_empty(&self) -> bool { self.entries.is_empty() }

    /// Binary search in the sorted index to find the position for a key.
    fn search(&self, key: &K) -> Result<usize, usize> {
        self.sorted_idx.binary_search_by(|&idx| self.entries[idx].0.cmp(key))
    }

    /// Insert a key-value pair. Returns the old value if the key existed.
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        match self.search(&key) {
            Result::Ok(pos) => {
                // Key exists — update in place.
                let entry_idx = self.sorted_idx[pos];
                let old = crate::mem::replace(&mut self.entries[entry_idx].1, value);
                Option::Some(old)
            }
            Result::Err(pos) => {
                // New key — append to entries, insert into sorted index.
                let entry_idx = self.entries.len();
                self.entries.push((key, value));
                self.sorted_idx.insert(pos, entry_idx);
                Option::None
            }
        }
    }

    /// Get a reference to the value for a key.
    pub fn get(&self, key: &K) -> Option<&V> {
        match self.search(key) {
            Result::Ok(pos) => {
                let entry_idx = self.sorted_idx[pos];
                Option::Some(&self.entries[entry_idx].1)
            }
            Result::Err(_) => Option::None,
        }
    }

    /// Get a mutable reference.
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {
        match self.search(key) {
            Result::Ok(pos) => {
                let entry_idx = self.sorted_idx[pos];
                Option::Some(&mut self.entries[entry_idx].1)
            }
            Result::Err(_) => Option::None,
        }
    }

    /// Check if a key is present.
    pub fn contains_key(&self, key: &K) -> bool {
        self.search(key).is_ok()
    }

    /// Remove a key. Returns the value if found.
    /// Note: This is O(n) because it must compact the entries vector.
    pub fn remove(&mut self, key: &K) -> Option<V> {
        match self.search(key) {
            Result::Ok(pos) => {
                let entry_idx = self.sorted_idx.remove(pos);
                let (_, value) = self.entries.remove(entry_idx);
                // Fix up sorted indices: any index > entry_idx must be decremented.
                for idx in &mut self.sorted_idx {
                    if *idx > entry_idx { *idx -= 1; }
                }
                Option::Some(value)
            }
            Result::Err(_) => Option::None,
        }
    }

    /// Iterate in insertion order.
    pub fn iter(&self) -> impl Iterator<Item = (&K, &V)> {
        self.entries.iter().map(|(k, v)| (k, v))
    }

    /// Iterate keys in insertion order.
    pub fn keys(&self) -> impl Iterator<Item = &K> {
        self.entries.iter().map(|(k, _)| k)
    }

    /// Iterate values in insertion order.
    pub fn values(&self) -> impl Iterator<Item = &V> {
        self.entries.iter().map(|(_, v)| v)
    }

    /// Iterate in sorted key order.
    pub fn iter_sorted(&self) -> impl Iterator<Item = (&K, &V)> {
        self.sorted_idx.iter().map(move |&idx| {
            let (ref k, ref v) = self.entries[idx];
            (k, v)
        })
    }

    /// Clear all entries.
    pub fn clear(&mut self) {
        self.entries.clear();
        self.sorted_idx.clear();
    }
}

// ─── OrderedSet ───────────────────────────────────────────────────────────────

/// A set that preserves insertion order and provides deterministic iteration.
pub struct OrderedSet<T: Ord + Eq> {
    inner: OrderedMap<T, ()>,
}

impl<T: Ord + Eq + Clone> OrderedSet<T> {
    pub fn new() -> OrderedSet<T> {
        OrderedSet { inner: OrderedMap::new() }
    }

    pub fn len(&self) -> usize { self.inner.len() }
    pub fn is_empty(&self) -> bool { self.inner.is_empty() }

    /// Insert a value. Returns true if it was new.
    pub fn insert(&mut self, value: T) -> bool {
        self.inner.insert(value, ()).is_none()
    }

    /// Check membership.
    pub fn contains(&self, value: &T) -> bool {
        self.inner.contains_key(value)
    }

    /// Remove a value. Returns true if it was present.
    pub fn remove(&mut self, value: &T) -> bool {
        self.inner.remove(value).is_some()
    }

    /// Iterate in insertion order.
    pub fn iter(&self) -> impl Iterator<Item = &T> {
        self.inner.keys()
    }

    /// Iterate in sorted order.
    pub fn iter_sorted(&self) -> impl Iterator<Item = &T> {
        self.inner.iter_sorted().map(|(k, _)| k)
    }

    /// Set union (preserves order of self, then other).
    pub fn union(&self, other: &OrderedSet<T>) -> OrderedSet<T> {
        let mut result = OrderedSet::new();
        for v in self.iter() { result.insert(v.clone()); }
        for v in other.iter() { result.insert(v.clone()); }
        result
    }

    /// Set intersection (preserves order of self).
    pub fn intersection(&self, other: &OrderedSet<T>) -> OrderedSet<T> {
        let mut result = OrderedSet::new();
        for v in self.iter() {
            if other.contains(v) { result.insert(v.clone()); }
        }
        result
    }

    /// Set difference: self - other.
    pub fn difference(&self, other: &OrderedSet<T>) -> OrderedSet<T> {
        let mut result = OrderedSet::new();
        for v in self.iter() {
            if !other.contains(v) { result.insert(v.clone()); }
        }
        result
    }

    pub fn clear(&mut self) { self.inner.clear(); }
}

// ─── StableVec ────────────────────────────────────────────────────────────────

/// A vector that guarantees stable indices across removals.
/// Removed slots are tombstoned and reused on subsequent inserts.
/// Iteration skips tombstones. Suitable for entity-component systems
/// and arenas where stable handles are needed.
pub struct StableVec<T> {
    slots: Vec<Option<T>>,
    free_list: Vec<usize>,
    count: usize,
    generation: Vec<u32>,
}

/// A handle into a StableVec, carrying a generation for ABA safety.
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub struct StableIndex {
    pub index: usize,
    pub generation: u32,
}

impl<T> StableVec<T> {
    pub fn new() -> StableVec<T> {
        StableVec { slots: Vec::new(), free_list: Vec::new(), count: 0, generation: Vec::new() }
    }

    pub fn len(&self) -> usize { self.count }
    pub fn is_empty(&self) -> bool { self.count == 0 }
    pub fn capacity(&self) -> usize { self.slots.len() }

    /// Insert a value and return its stable index.
    pub fn insert(&mut self, value: T) -> StableIndex {
        if let Option::Some(idx) = self.free_list.pop() {
            self.slots[idx] = Option::Some(value);
            self.count += 1;
            StableIndex { index: idx, generation: self.generation[idx] }
        } else {
            let idx = self.slots.len();
            self.slots.push(Option::Some(value));
            self.generation.push(0);
            self.count += 1;
            StableIndex { index: idx, generation: 0 }
        }
    }

    /// Get a reference by stable index.
    pub fn get(&self, handle: StableIndex) -> Option<&T> {
        if handle.index >= self.slots.len() { return Option::None; }
        if self.generation[handle.index] != handle.generation { return Option::None; }
        self.slots[handle.index].as_ref()
    }

    /// Get a mutable reference by stable index.
    pub fn get_mut(&mut self, handle: StableIndex) -> Option<&mut T> {
        if handle.index >= self.slots.len() { return Option::None; }
        if self.generation[handle.index] != handle.generation { return Option::None; }
        self.slots[handle.index].as_mut()
    }

    /// Remove by stable index. Returns the value if found.
    pub fn remove(&mut self, handle: StableIndex) -> Option<T> {
        if handle.index >= self.slots.len() { return Option::None; }
        if self.generation[handle.index] != handle.generation { return Option::None; }
        let value = self.slots[handle.index].take();
        if value.is_some() {
            self.generation[handle.index] += 1;
            self.free_list.push(handle.index);
            self.count -= 1;
        }
        value
    }

    /// Check if a handle is still valid.
    pub fn is_valid(&self, handle: StableIndex) -> bool {
        handle.index < self.slots.len() &&
        self.generation[handle.index] == handle.generation &&
        self.slots[handle.index].is_some()
    }

    /// Iterate over all live values.
    pub fn iter(&self) -> impl Iterator<Item = (StableIndex, &T)> {
        self.slots.iter().enumerate()
            .filter_map(move |(i, slot)| {
                slot.as_ref().map(|v| (
                    StableIndex { index: i, generation: self.generation[i] },
                    v,
                ))
            })
    }

    /// Clear all entries, incrementing all generations.
    pub fn clear(&mut self) {
        for i in 0..self.slots.len() {
            if self.slots[i].is_some() {
                self.slots[i] = Option::None;
                self.generation[i] += 1;
            }
        }
        self.free_list.clear();
        for i in (0..self.slots.len()).rev() {
            self.free_list.push(i);
        }
        self.count = 0;
    }
}

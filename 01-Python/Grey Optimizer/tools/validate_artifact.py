#!/usr/bin/env python3
"""
Grey Optimizer - Artifact Validator

Validates proof artifacts generated by Grey Optimizer memory enforcement actions.
Checks JSON schema, HMAC signatures, and content hash integrity.

Usage:
    python tools/validate_artifact.py <artifact_path>
    python tools/validate_artifact.py --all
    python tools/validate_artifact.py --action-id <action_id>

Features:
    - Schema validation for before/after snapshots
    - HMAC signature verification for live artifacts
    - Content hash integrity check
    - Simulation artifact detection (explicitly unsigned)
    - Batch validation of all artifacts
"""

import argparse
import hashlib
import hmac
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Colors for terminal output
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    NC = '\033[0m'
    
    @classmethod
    def disable(cls):
        cls.RED = cls.GREEN = cls.YELLOW = cls.BLUE = cls.CYAN = cls.BOLD = cls.DIM = cls.NC = ''


if not sys.stdout.isatty():
    Colors.disable()


# Paths
ARTIFACTS_DIR = Path(os.environ.get(
    "GREY_ARTIFACTS_DIR",
    "/var/lib/grey-optimizer/artifacts"
))

HMAC_KEY_PATH = Path(os.environ.get(
    "GREY_HMAC_KEY_PATH",
    "/var/lib/grey-optimizer/.hmac_key"
))

AUDIT_DB_PATH = Path(os.environ.get(
    "GREY_AUDIT_DB",
    "/var/lib/grey-optimizer/audit.db"
))


# Expected schema for memory snapshots
SNAPSHOT_SCHEMA = {
    "required": ["timestamp", "action_id", "snapshot_type"],
    "properties": {
        "timestamp": {"type": "string"},
        "action_id": {"type": "string"},
        "snapshot_type": {"type": "string", "enum": ["before", "after"]},
        "total_mb": {"type": "number"},
        "available_mb": {"type": "number"},
        "used_mb": {"type": "number"},
        "used_percent": {"type": "number"},
        "processes": {"type": "array"},
        "ksm": {"type": "object"},
        "meminfo": {"type": "object"},
    }
}

COMPARISON_SCHEMA = {
    "required": ["action_id", "before", "after"],
    "properties": {
        "action_id": {"type": "string"},
        "before": {"type": "object"},
        "after": {"type": "object"},
        "delta_mb": {"type": "number"},
        "delta_percent": {"type": "number"},
    }
}


def print_success(msg: str):
    print(f"{Colors.GREEN}✓{Colors.NC} {msg}")


def print_error(msg: str):
    print(f"{Colors.RED}✗{Colors.NC} {msg}")


def print_warning(msg: str):
    print(f"{Colors.YELLOW}⚠{Colors.NC} {msg}")


def print_info(msg: str):
    print(f"{Colors.BLUE}ℹ{Colors.NC} {msg}")


def load_hmac_key() -> Optional[bytes]:
    """Load the HMAC key from file."""
    if not HMAC_KEY_PATH.exists():
        return None
    try:
        return HMAC_KEY_PATH.read_bytes()
    except Exception:
        return None


def compute_content_hash(content: bytes) -> str:
    """Compute SHA-256 hash of content."""
    return hashlib.sha256(content).hexdigest()


def compute_hmac(key: bytes, data: str) -> str:
    """Compute HMAC-SHA256 signature."""
    return hmac.new(key, data.encode('utf-8'), hashlib.sha256).hexdigest()


def verify_hmac(key: bytes, data: str, signature: str) -> bool:
    """Verify HMAC signature."""
    expected = compute_hmac(key, data)
    return hmac.compare_digest(expected, signature)


def validate_schema(data: Dict[str, Any], schema: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """
    Validate data against a simple schema.
    
    Returns (is_valid, list_of_errors)
    """
    errors = []
    
    # Check required fields
    for field in schema.get("required", []):
        if field not in data:
            errors.append(f"Missing required field: {field}")
    
    # Check property types
    props = schema.get("properties", {})
    for field, spec in props.items():
        if field not in data:
            continue
        
        value = data[field]
        expected_type = spec.get("type")
        
        if expected_type == "string" and not isinstance(value, str):
            errors.append(f"Field '{field}' should be string, got {type(value).__name__}")
        elif expected_type == "number" and not isinstance(value, (int, float)):
            errors.append(f"Field '{field}' should be number, got {type(value).__name__}")
        elif expected_type == "array" and not isinstance(value, list):
            errors.append(f"Field '{field}' should be array, got {type(value).__name__}")
        elif expected_type == "object" and not isinstance(value, dict):
            errors.append(f"Field '{field}' should be object, got {type(value).__name__}")
        
        # Check enum
        if "enum" in spec and value not in spec["enum"]:
            errors.append(f"Field '{field}' should be one of {spec['enum']}, got '{value}'")
    
    return len(errors) == 0, errors


def detect_artifact_type(data: Dict[str, Any]) -> str:
    """Detect the type of artifact from its content."""
    if "snapshot_type" in data:
        return f"{data['snapshot_type']}_snapshot"
    if "before" in data and "after" in data:
        return "comparison"
    if "action" in data and "outcome" in data:
        return "audit_entry"
    return "unknown"


def validate_artifact_file(
    artifact_path: Path,
    hmac_key: Optional[bytes] = None,
    verbose: bool = False,
) -> Dict[str, Any]:
    """
    Validate a single artifact file.
    
    Returns a result dict with:
        valid: bool
        artifact_path: str
        artifact_type: str
        simulated: bool
        signed: bool
        errors: list
        warnings: list
    """
    result = {
        "valid": True,
        "artifact_path": str(artifact_path),
        "artifact_type": "unknown",
        "simulated": False,
        "signed": False,
        "content_hash": "",
        "errors": [],
        "warnings": [],
    }
    
    # Check file exists
    if not artifact_path.exists():
        result["valid"] = False
        result["errors"].append(f"File not found: {artifact_path}")
        return result
    
    # Read file content
    try:
        content = artifact_path.read_bytes()
        result["content_hash"] = compute_content_hash(content)
        result["file_size"] = len(content)
    except Exception as e:
        result["valid"] = False
        result["errors"].append(f"Could not read file: {e}")
        return result
    
    # Parse JSON
    try:
        data = json.loads(content.decode('utf-8'))
    except json.JSONDecodeError as e:
        result["valid"] = False
        result["errors"].append(f"Invalid JSON: {e}")
        return result
    
    # Detect artifact type
    artifact_type = detect_artifact_type(data)
    result["artifact_type"] = artifact_type
    
    # Check if simulated
    if data.get("simulated", False) or data.get("simulation", False):
        result["simulated"] = True
        result["warnings"].append("This is a simulation artifact (unsigned by design)")
    
    # Validate schema based on type
    if artifact_type in ("before_snapshot", "after_snapshot"):
        valid, errors = validate_schema(data, SNAPSHOT_SCHEMA)
        if not valid:
            result["valid"] = False
            result["errors"].extend(errors)
    elif artifact_type == "comparison":
        valid, errors = validate_schema(data, COMPARISON_SCHEMA)
        if not valid:
            result["valid"] = False
            result["errors"].extend(errors)
    else:
        result["warnings"].append(f"Unknown artifact type: {artifact_type}")
    
    # Extract metadata
    result["action_id"] = data.get("action_id", "unknown")
    result["timestamp"] = data.get("timestamp", "unknown")
    
    # Check for HMAC signature in metadata or companion file
    signature = data.get("hmac_signature", "")
    signature_file = artifact_path.with_suffix(artifact_path.suffix + ".sig")
    
    if not signature and signature_file.exists():
        try:
            signature = signature_file.read_text().strip()
        except Exception:
            pass
    
    if signature:
        result["has_signature"] = True
        
        if hmac_key:
            # Verify HMAC
            # The signature is computed over the content hash + action_id + artifact_type
            signature_data = json.dumps({
                "action_id": data.get("action_id", ""),
                "artifact_type": artifact_type.replace("_snapshot", ""),
                "content_hash": result["content_hash"],
                "file_size": result["file_size"],
                "artifact_path": str(artifact_path),
            }, sort_keys=True)
            
            if verify_hmac(hmac_key, signature_data, signature):
                result["signed"] = True
                result["signature_valid"] = True
            else:
                result["signature_valid"] = False
                if not result["simulated"]:
                    result["valid"] = False
                    result["errors"].append("HMAC signature verification failed")
        else:
            result["warnings"].append("Cannot verify signature: HMAC key not available")
    else:
        result["has_signature"] = False
        if not result["simulated"]:
            result["warnings"].append("No HMAC signature found")
    
    return result


def validate_all_artifacts(
    artifacts_dir: Path = ARTIFACTS_DIR,
    hmac_key: Optional[bytes] = None,
    verbose: bool = False,
) -> Dict[str, Any]:
    """
    Validate all artifacts in the directory.
    
    Returns summary with individual results.
    """
    results = {
        "artifacts_dir": str(artifacts_dir),
        "total": 0,
        "valid": 0,
        "invalid": 0,
        "simulated": 0,
        "signed": 0,
        "errors": [],
        "artifacts": [],
    }
    
    if not artifacts_dir.exists():
        results["errors"].append(f"Artifacts directory not found: {artifacts_dir}")
        return results
    
    # Find all JSON files
    artifact_files = list(artifacts_dir.glob("**/*.json"))
    results["total"] = len(artifact_files)
    
    for artifact_path in sorted(artifact_files):
        result = validate_artifact_file(artifact_path, hmac_key, verbose)
        results["artifacts"].append(result)
        
        if result["valid"]:
            results["valid"] += 1
        else:
            results["invalid"] += 1
        
        if result["simulated"]:
            results["simulated"] += 1
        
        if result["signed"]:
            results["signed"] += 1
    
    return results


def validate_by_action_id(
    action_id: str,
    artifacts_dir: Path = ARTIFACTS_DIR,
    hmac_key: Optional[bytes] = None,
    verbose: bool = False,
) -> Dict[str, Any]:
    """
    Validate all artifacts for a specific action ID.
    """
    results = {
        "action_id": action_id,
        "found": False,
        "artifacts": [],
    }
    
    if not artifacts_dir.exists():
        results["error"] = f"Artifacts directory not found: {artifacts_dir}"
        return results
    
    # Search for artifacts with matching action_id
    for artifact_path in artifacts_dir.glob("**/*.json"):
        try:
            data = json.loads(artifact_path.read_text())
            if data.get("action_id") == action_id:
                result = validate_artifact_file(artifact_path, hmac_key, verbose)
                results["artifacts"].append(result)
                results["found"] = True
        except Exception:
            continue
    
    return results


def print_validation_result(result: Dict[str, Any], verbose: bool = False):
    """Pretty-print a single validation result."""
    path = result["artifact_path"]
    artifact_type = result["artifact_type"]
    
    status = f"{Colors.GREEN}VALID{Colors.NC}" if result["valid"] else f"{Colors.RED}INVALID{Colors.NC}"
    
    # Build status flags
    flags = []
    if result["simulated"]:
        flags.append(f"{Colors.YELLOW}SIM{Colors.NC}")
    if result.get("signed"):
        flags.append(f"{Colors.GREEN}SIGNED{Colors.NC}")
    elif result.get("has_signature") and not result.get("signature_valid"):
        flags.append(f"{Colors.RED}SIG-FAIL{Colors.NC}")
    
    flags_str = " ".join(flags) if flags else ""
    
    print(f"\n{Colors.BOLD}{Path(path).name}{Colors.NC}")
    print(f"  Status: {status} {flags_str}")
    print(f"  Type:   {artifact_type}")
    print(f"  Action: {result.get('action_id', 'N/A')}")
    
    if verbose:
        print(f"  Hash:   {result.get('content_hash', 'N/A')[:16]}...")
        print(f"  Size:   {result.get('file_size', 0)} bytes")
    
    for error in result.get("errors", []):
        print(f"  {Colors.RED}✗ {error}{Colors.NC}")
    
    if verbose:
        for warning in result.get("warnings", []):
            print(f"  {Colors.YELLOW}⚠ {warning}{Colors.NC}")


def print_summary(results: Dict[str, Any]):
    """Print validation summary."""
    print(f"\n{Colors.BOLD}{'═' * 60}{Colors.NC}")
    print(f"{Colors.BOLD}Validation Summary{Colors.NC}")
    print(f"{'═' * 60}")
    
    print(f"\nArtifacts Directory: {results['artifacts_dir']}")
    print(f"\nTotal:     {results['total']}")
    print(f"Valid:     {Colors.GREEN}{results['valid']}{Colors.NC}")
    print(f"Invalid:   {Colors.RED}{results['invalid']}{Colors.NC}")
    print(f"Simulated: {Colors.YELLOW}{results['simulated']}{Colors.NC}")
    print(f"Signed:    {Colors.CYAN}{results['signed']}{Colors.NC}")
    
    if results['errors']:
        print(f"\n{Colors.RED}Errors:{Colors.NC}")
        for error in results['errors']:
            print(f"  ✗ {error}")
    
    if results['invalid'] == 0:
        print(f"\n{Colors.GREEN}✓ All artifacts are valid!{Colors.NC}")
    else:
        print(f"\n{Colors.RED}✗ Some artifacts failed validation{Colors.NC}")


def main():
    parser = argparse.ArgumentParser(
        description="Validate Grey Optimizer proof artifacts",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s /var/lib/grey-optimizer/artifacts/snapshot_2024-01-15.json
  %(prog)s --all
  %(prog)s --all --verbose
  %(prog)s --action-id abc123
  %(prog)s --list

Validation checks:
  - JSON schema compliance
  - Content hash integrity
  - HMAC signature verification (for live artifacts)
  - Simulation artifact flagging
"""
    )
    
    parser.add_argument(
        "artifact",
        nargs="?",
        help="Path to artifact file to validate"
    )
    
    parser.add_argument(
        "--all",
        action="store_true",
        help="Validate all artifacts in the artifacts directory"
    )
    
    parser.add_argument(
        "--action-id",
        metavar="ID",
        help="Validate all artifacts for a specific action ID"
    )
    
    parser.add_argument(
        "--list",
        action="store_true",
        help="List all artifacts without validation"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed output"
    )
    
    parser.add_argument(
        "--artifacts-dir",
        type=Path,
        default=ARTIFACTS_DIR,
        help=f"Artifacts directory (default: {ARTIFACTS_DIR})"
    )
    
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output results as JSON"
    )
    
    args = parser.parse_args()
    
    # Load HMAC key
    hmac_key = load_hmac_key()
    if hmac_key:
        print_info(f"HMAC key loaded from {HMAC_KEY_PATH}")
    else:
        print_warning(f"HMAC key not found at {HMAC_KEY_PATH}")
        print_info("Signature verification will be skipped")
    
    # Handle --list
    if args.list:
        if not args.artifacts_dir.exists():
            print_error(f"Artifacts directory not found: {args.artifacts_dir}")
            return 1
        
        print(f"\n{Colors.BOLD}Artifacts in {args.artifacts_dir}:{Colors.NC}\n")
        
        for artifact_path in sorted(args.artifacts_dir.glob("**/*.json")):
            try:
                data = json.loads(artifact_path.read_text())
                action_id = data.get("action_id", "N/A")[:12]
                artifact_type = detect_artifact_type(data)
                simulated = "SIM" if data.get("simulated") else "   "
                
                print(f"  [{simulated}] {artifact_path.name:40} {artifact_type:20} {action_id}")
            except Exception as e:
                print(f"  [ERR] {artifact_path.name:40} (parse error)")
        
        return 0
    
    # Handle --all
    if args.all:
        results = validate_all_artifacts(args.artifacts_dir, hmac_key, args.verbose)
        
        if args.json:
            print(json.dumps(results, indent=2, default=str))
        else:
            for result in results["artifacts"]:
                print_validation_result(result, args.verbose)
            print_summary(results)
        
        return 0 if results["invalid"] == 0 else 1
    
    # Handle --action-id
    if args.action_id:
        results = validate_by_action_id(args.action_id, args.artifacts_dir, hmac_key, args.verbose)
        
        if args.json:
            print(json.dumps(results, indent=2, default=str))
        else:
            if not results["found"]:
                print_error(f"No artifacts found for action ID: {args.action_id}")
                return 1
            
            print(f"\n{Colors.BOLD}Artifacts for action: {args.action_id}{Colors.NC}")
            for result in results["artifacts"]:
                print_validation_result(result, args.verbose)
        
        return 0
    
    # Handle single artifact
    if args.artifact:
        artifact_path = Path(args.artifact)
        result = validate_artifact_file(artifact_path, hmac_key, args.verbose)
        
        if args.json:
            print(json.dumps(result, indent=2, default=str))
        else:
            print_validation_result(result, args.verbose)
        
        return 0 if result["valid"] else 1
    
    # No arguments - show help
    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())

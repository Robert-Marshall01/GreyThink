from datetime import datetime, timezone, timedelta

from powerapp.emissions import simulate_postponement


def _make_forecast(base=400.0, low_start_hour=3, low_value=100.0, hours=24):
    now = datetime.now(timezone.utc).replace(minute=0, second=0, microsecond=0)
    fc = []
    for h in range(hours):
        dt = now + timedelta(hours=h)
        if dt.hour == low_start_hour or dt.hour == (low_start_hour + 1) % 24:
            ci = low_value
        else:
            ci = base
        fc.append({'timestamp': dt.isoformat(), 'intensity': ci})
    return fc


def test_simulate_postponement_basic():
    # Task: 60 min, 100 W
    task = {'id': 't1', 'name': 'Test Task', 'duration_min': 60, 'power_w': 100.0}
    forecast = _make_forecast()
    # choose a low window where two consecutive hours are low so window_hours=2 covers both
    low_idx = next(i for i, p in enumerate(forecast) if p['intensity'] == 100.0 and forecast[(i+1) % len(forecast)]['intensity'] == 100.0)
    start = forecast[low_idx]['timestamp']
    res = simulate_postponement(task, forecast, start, window_hours=2, current_intensity=400.0)
    assert 'task_kwh' in res
    assert abs(res['task_kwh'] - 0.1) < 1e-9
    # CO2 now: 0.1 kwh * 400 g/kWh / 1000 = 0.04 kg
    assert abs(res['co2_now_kg'] - 0.04) < 1e-6
    # CO2 in window: 0.1 * 100 / 1000 = 0.01 kg
    assert abs(res['co2_in_window_kg'] - 0.01) < 1e-6
    assert abs(res['savings_kg'] - 0.03) < 1e-6
    assert res['window_start'] == start
    assert len(res['series']) > 0


def test_simulate_postponement_per_app_impacts():
    # Task: 60 min, 100 W
    task = {'id': 't3', 'name': 'PerApp Test', 'duration_min': 60, 'power_w': 100.0}
    # Forecast aligned with timestamps generated by _make_forecast
    forecast = _make_forecast()
    # find a low window with two consecutive low hours
    low_idx = next(i for i, p in enumerate(forecast) if p['intensity'] == 100.0 and forecast[(i+1) % len(forecast)]['intensity'] == 100.0)
    start = forecast[low_idx]['timestamp']
    # build per_app_series with appA dominant during low window hours
    per_app_series = []
    for i, p in enumerate(forecast):
        if i in (low_idx, (low_idx+1) % len(forecast)):
            per_app_series.append({'timestamp': p['timestamp'], 'per_app_cpu': {'appA': 80.0, 'appB': 20.0}})
        else:
            per_app_series.append({'timestamp': p['timestamp'], 'per_app_cpu': {'appA': 10.0, 'appB': 10.0}})

    res = simulate_postponement(task, forecast, start, window_hours=2, current_intensity=400.0, per_app_series=per_app_series)
    assert 'per_app_impacts' in res
    impacts = res['per_app_impacts']
    assert 'appA' in impacts and 'appB' in impacts
    # sum of per-app kwh should approximate the task kwh
    total_kwh = sum(d['kwh'] for d in impacts.values())
    assert abs(total_kwh - res['task_kwh']) < 1e-6


def test_simulate_with_missing_window():
    task = {'id': 't2', 'name': 'Another', 'duration_min': 30, 'power_w': 50.0}
    forecast = []
    res2 = simulate_postponement(task, forecast, None, window_hours=2, current_intensity=300.0)
    assert res2['co2_in_window_kg'] is None
    assert res2['savings_kg'] is None

// concurrent::channel — Message passing (MPSC)
//
// Channels provide communication between concurrent tasks.
// Uses the built-in channel(), send(), receive() functions.

// Creates a new unbounded channel. Returns { sender, receiver }.
fn Channel_new() {
    fn ch() { channel() }
    {
        sender: { _type: "Sender", channel: ch() },
        receiver: { _type: "Receiver", channel: ch() }
    }
}

// Creates a bounded channel with a capacity limit.
fn Channel_bounded(capacity) {
    {
        sender: { _type: "Sender", buffer: [], capacity: capacity },
        receiver: { _type: "Receiver", buffer: [] }
    }
}

// Sends a message through the sender.
fn channel_send(sender, message) {
    send(get(sender, "channel"), message)
}

// Receives a message from the receiver (blocking).
fn channel_recv(receiver) {
    receive(get(receiver, "channel"))
}

// Tries to receive without blocking. Returns Some(msg) or None.
fn channel_try_recv(receiver) {
    try_catch(
        fn() { Some(receive(get(receiver, "channel"))) },
        fn(e) { None() }
    )
}

// Closes the sender side of the channel.
fn channel_close(sender) {
    set(sender, "closed", true)
}

// Returns true if the sender is closed.
fn channel_is_closed(sender) {
    get(sender, "closed") == true
}

// ── Broadcast Channel ───────────────────────────────────────────

// Creates a broadcast channel (one sender, multiple receivers).
fn Broadcast_new() {
    { _type: "Broadcast", subscribers: [], messages: [] }
}

// Subscribes to the broadcast channel.
fn broadcast_subscribe(bc) {
    fn sub_id() { len(get(bc, "subscribers")) }
    fn subscriber() { { id: sub_id(), queue: [] } }
    {
        broadcast: set(bc, "subscribers", push(get(bc, "subscribers"), subscriber())),
        subscription: subscriber()
    }
}

// Broadcasts a message to all subscribers.
fn broadcast_send(bc, message) {
    set(bc, "messages", push(get(bc, "messages"), message))
}

// Receives from a subscription.
fn broadcast_recv(bc, subscription) {
    fn id() { get(subscription, "id") }
    fn msgs() { get(bc, "messages") }
    fn read_pos() { get(subscription, "read_pos") }
    if_then(is_nil(read_pos()),
        fn() { if_then(len(msgs()) > 0, fn() { head(msgs()) }, fn() { nil }) },
        fn() { if_then(read_pos() < len(msgs()),
            fn() { get(msgs(), read_pos()) },
            fn() { nil }) })
}

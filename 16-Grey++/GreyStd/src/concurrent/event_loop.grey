// concurrent::event_loop â€” Async event loop
//
// A simple event loop that processes callbacks and timers.

// Creates a new event loop.
fn EventLoop_new() {
    {
        _type: "EventLoop",
        tasks: [],
        timers: [],
        running: false,
        tick: 0
    }
}

// Schedules a callback to run on the next tick.
fn loop_next_tick(evloop, callback) {
    set(evloop, "tasks", push(get(evloop, "tasks"), {
        callback: callback,
        tick: get(evloop, "tick") + 1
    }))
}

// Schedules a callback to run after a delay (in ms).
fn loop_set_timeout(evloop, callback, delay_ms) {
    set(evloop, "timers", push(get(evloop, "timers"), {
        callback: callback,
        fire_at: timestamp() + delay_ms,
        repeat: false
    }))
}

// Schedules a callback to repeat at an interval (in ms).
fn loop_set_interval(evloop, callback, interval_ms) {
    set(evloop, "timers", push(get(evloop, "timers"), {
        callback: callback,
        fire_at: timestamp() + interval_ms,
        interval: interval_ms,
        repeat: true
    }))
}

// Runs one tick of the event loop.
fn loop_tick(evloop) {
    fn current_tick() { get(evloop, "tick") + 1 }
    fn now_ms() { timestamp() }

    // Execute ready tasks
    fn ready_tasks() {
        filter(get(evloop, "tasks"), fn(t) { get(t, "tick") <= current_tick() })
    }
    fn remaining_tasks() {
        filter(get(evloop, "tasks"), fn(t) { get(t, "tick") > current_tick() })
    }
    forEach(ready_tasks(), fn(t) { get(t, "callback")() })

    // Execute ready timers
    fn ready_timers() {
        filter(get(evloop, "timers"), fn(t) { get(t, "fire_at") <= now_ms() })
    }
    fn remaining_timers() {
        filter(get(evloop, "timers"), fn(t) { get(t, "fire_at") > now_ms() })
    }
    forEach(ready_timers(), fn(t) { get(t, "callback")() })

    // Re-schedule repeating timers
    fn repeating() {
        map(
            filter(ready_timers(), fn(t) { get(t, "repeat") }),
            fn(t) { set(t, "fire_at", now_ms() + get(t, "interval")) }
        )
    }

    merge(evloop, {
        tasks: remaining_tasks(),
        timers: concat(remaining_timers(), repeating()),
        tick: current_tick()
    })
}

// Runs the event loop until no tasks remain.
fn loop_run(evloop) {
    fn step(ev) {
        fn has_work() { len(get(ev, "tasks")) > 0 }
        fn has_timers() { len(get(ev, "timers")) > 0 }
        if_then(has_work(),
            fn() { step(loop_tick(ev)) },
            fn() { if_then(has_timers(),
                fn() { step(loop_tick(ev)) },
                fn() { ev }) })
    }
    step(set(evloop, "running", true))
}

// Returns the number of pending tasks.
fn loop_pending_count(evloop) {
    len(get(evloop, "tasks")) + len(get(evloop, "timers"))
}

// Returns true if the loop has pending work.
fn loop_has_pending(evloop) {
    loop_pending_count(evloop) > 0
}

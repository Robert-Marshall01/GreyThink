/// serial::json — JSON serialization and deserialization.

use crate::core::string::String;
use crate::core::vec::Vec;
use crate::core::map::HashMap;
use crate::core::option::Option;
use crate::serial::{Serialize, Deserialize, SerializeError, DeserializeError};

/// A JSON value.
pub enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    Str(String),
    Array(Vec<JsonValue>),
    Object(Vec<(String, JsonValue)>),  // ordered map
}

impl JsonValue {
    pub fn is_null(self) -> bool   { match self { JsonValue::Null => true, _ => false } }
    pub fn is_bool(self) -> bool   { match self { JsonValue::Bool(_) => true, _ => false } }
    pub fn is_number(self) -> bool { match self { JsonValue::Number(_) => true, _ => false } }
    pub fn is_string(self) -> bool { match self { JsonValue::Str(_) => true, _ => false } }
    pub fn is_array(self) -> bool  { match self { JsonValue::Array(_) => true, _ => false } }
    pub fn is_object(self) -> bool { match self { JsonValue::Object(_) => true, _ => false } }

    pub fn as_bool(self) -> Option<bool> {
        match self { JsonValue::Bool(b) => Some(*b), _ => None }
    }

    pub fn as_f64(self) -> Option<f64> {
        match self { JsonValue::Number(n) => Some(*n), _ => None }
    }

    pub fn as_i64(self) -> Option<i64> {
        match self { JsonValue::Number(n) => Some(*n as i64), _ => None }
    }

    pub fn as_str(self) -> Option<&str> {
        match self { JsonValue::Str(s) => Some(s.as_str()), _ => None }
    }

    pub fn as_array(self) -> Option<&Vec<JsonValue>> {
        match self { JsonValue::Array(a) => Some(a), _ => None }
    }

    pub fn as_object(self) -> Option<&Vec<(String, JsonValue)>> {
        match self { JsonValue::Object(o) => Some(o), _ => None }
    }

    /// Object field access by key.
    pub fn get(self, key: &str) -> Option<&JsonValue> {
        match self {
            JsonValue::Object(pairs) => {
                pairs.iter().find(|(k, _)| k == key).map(|(_, v)| v)
            }
            _ => None,
        }
    }

    /// Array index access.
    pub fn index(self, i: usize) -> Option<&JsonValue> {
        match self {
            JsonValue::Array(arr) => arr.get(i),
            _ => None,
        }
    }
}

/// Serializes a value to a JSON string.
pub fn to_json<T: Serialize>(value: &T) -> Result<String, SerializeError> {
    let mut ser = JsonSerializer::new();
    value.serialize(&mut ser)?;
    Ok(ser.output)
}

/// Serializes a value to a pretty-printed JSON string.
pub fn to_json_pretty<T: Serialize>(value: &T) -> Result<String, SerializeError> {
    let mut ser = JsonSerializer::pretty();
    value.serialize(&mut ser)?;
    Ok(ser.output)
}

/// Parses a JSON string into a JsonValue.
pub fn parse(input: &str) -> Result<JsonValue, DeserializeError> {
    let mut parser = JsonParser::new(input);
    parser.parse_value()
}

/// Deserializes a JSON string into a typed value.
pub fn from_json<T: Deserialize>(input: &str) -> Result<T, DeserializeError> {
    let value = parse(input)?;
    let mut deser = JsonDeserializer::new(value);
    T::deserialize(&mut deser)
}

/// Alias for to_json.
pub fn to_string<T: Serialize>(value: &T) -> Result<String, SerializeError> {
    to_json(value)
}

/// Alias for from_json.
pub fn from_str<T: Deserialize>(input: &str) -> Result<T, DeserializeError> {
    from_json(input)
}

// ─── JSON Serializer ────────────────────────────────────────

struct JsonSerializer {
    output: String,
    pretty: bool,
    indent: usize,
    needs_comma: Vec<bool>,
}

impl JsonSerializer {
    fn new() -> JsonSerializer {
        JsonSerializer { output: String::new(), pretty: false, indent: 0, needs_comma: Vec::new() }
    }

    fn pretty() -> JsonSerializer {
        JsonSerializer { output: String::new(), pretty: true, indent: 0, needs_comma: Vec::new() }
    }

    fn write_indent(mut self) {
        if self.pretty {
            self.output.push('\n');
            for _ in 0..self.indent {
                self.output.push_str("  ");
            }
        }
    }

    fn maybe_comma(mut self) {
        if let Some(needs) = self.needs_comma.last() {
            if *needs {
                self.output.push(',');
            }
        }
        if let Some(last) = self.needs_comma.last_mut() {
            *last = true;
        }
    }
}

impl Serializer for JsonSerializer {
    fn serialize_bool(mut self, v: bool) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push_str(if v { "true" } else { "false" });
        Ok(())
    }

    fn serialize_i64(mut self, v: i64) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push_str(&v.to_string());
        Ok(())
    }

    fn serialize_u64(mut self, v: u64) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push_str(&v.to_string());
        Ok(())
    }

    fn serialize_f64(mut self, v: f64) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push_str(&v.to_string());
        Ok(())
    }

    fn serialize_str(mut self, v: &str) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push('"');
        for ch in v.chars() {
            match ch {
                '"'  => self.output.push_str("\\\""),
                '\\' => self.output.push_str("\\\\"),
                '\n' => self.output.push_str("\\n"),
                '\r' => self.output.push_str("\\r"),
                '\t' => self.output.push_str("\\t"),
                c if (c as u32) < 0x20 => {
                    self.output.push_str(&format!("\\u{:04x}", c as u32));
                }
                c => self.output.push(c),
            }
        }
        self.output.push('"');
        Ok(())
    }

    fn serialize_bytes(mut self, v: &[u8]) -> Result<(), SerializeError> {
        let encoded = crate::serial::binary::base64_encode(v);
        self.serialize_str(&encoded)
    }

    fn serialize_none(mut self) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push_str("null");
        Ok(())
    }

    fn serialize_some<T: Serialize>(mut self, value: &T) -> Result<(), SerializeError> {
        value.serialize(self)
    }

    fn serialize_seq_begin(mut self, _len: Option<usize>) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push('[');
        self.indent = self.indent + 1;
        self.needs_comma.push(false);
        Ok(())
    }

    fn serialize_seq_element<T: Serialize>(mut self, value: &T) -> Result<(), SerializeError> {
        self.write_indent();
        value.serialize(self)
    }

    fn serialize_seq_end(mut self) -> Result<(), SerializeError> {
        self.indent = self.indent - 1;
        self.needs_comma.pop();
        self.write_indent();
        self.output.push(']');
        Ok(())
    }

    fn serialize_map_begin(mut self, _len: Option<usize>) -> Result<(), SerializeError> {
        self.maybe_comma();
        self.output.push('{');
        self.indent = self.indent + 1;
        self.needs_comma.push(false);
        Ok(())
    }

    fn serialize_map_key<T: Serialize>(mut self, key: &T) -> Result<(), SerializeError> {
        self.write_indent();
        key.serialize(self)?;
        self.output.push(':');
        if self.pretty { self.output.push(' '); }
        // Next value should not have a comma before it
        if let Some(last) = self.needs_comma.last_mut() { *last = false; }
        Ok(())
    }

    fn serialize_map_value<T: Serialize>(mut self, value: &T) -> Result<(), SerializeError> {
        value.serialize(self)?;
        if let Some(last) = self.needs_comma.last_mut() { *last = true; }
        Ok(())
    }

    fn serialize_map_end(mut self) -> Result<(), SerializeError> {
        self.indent = self.indent - 1;
        self.needs_comma.pop();
        self.write_indent();
        self.output.push('}');
        Ok(())
    }

    fn serialize_struct_begin(mut self, _name: &str, _len: usize) -> Result<(), SerializeError> {
        self.serialize_map_begin(None)
    }

    fn serialize_struct_field<T: Serialize>(mut self, key: &str, value: &T) -> Result<(), SerializeError> {
        self.serialize_map_key(&key)?;
        self.serialize_map_value(value)
    }

    fn serialize_struct_end(mut self) -> Result<(), SerializeError> {
        self.serialize_map_end()
    }
}

// ─── JSON Parser ────────────────────────────────────────────

struct JsonParser {
    input: Vec<char>,
    pos: usize,
}

impl JsonParser {
    fn new(s: &str) -> JsonParser {
        JsonParser { input: s.chars().collect(), pos: 0 }
    }

    fn peek(self) -> Option<char> {
        self.skip_whitespace_peek()
    }

    fn skip_whitespace_peek(self) -> Option<char> {
        let mut p = self.pos;
        while p < self.input.len() && self.input[p].is_whitespace() {
            p = p + 1;
        }
        if p < self.input.len() { Some(self.input[p]) } else { None }
    }

    fn skip_whitespace(mut self) {
        while self.pos < self.input.len() && self.input[self.pos].is_whitespace() {
            self.pos = self.pos + 1;
        }
    }

    fn advance(mut self) -> Option<char> {
        if self.pos < self.input.len() {
            let c = self.input[self.pos];
            self.pos = self.pos + 1;
            Some(c)
        } else {
            None
        }
    }

    fn expect(mut self, ch: char) -> Result<(), DeserializeError> {
        self.skip_whitespace();
        match self.advance() {
            Some(c) if c == ch => Ok(()),
            Some(c) => Err(DeserializeError::Message(format!("expected '{}', got '{}'", ch, c))),
            None => Err(DeserializeError::Eof),
        }
    }

    fn parse_value(mut self) -> Result<JsonValue, DeserializeError> {
        self.skip_whitespace();
        match self.peek() {
            Some('"') => self.parse_string().map(JsonValue::Str),
            Some('{') => self.parse_object(),
            Some('[') => self.parse_array(),
            Some('t') | Some('f') => self.parse_bool().map(JsonValue::Bool),
            Some('n') => self.parse_null(),
            Some(c) if c == '-' || c.is_ascii_digit() => self.parse_number().map(JsonValue::Number),
            Some(c) => Err(DeserializeError::Message(format!("unexpected char: '{}'", c))),
            None => Err(DeserializeError::Eof),
        }
    }

    fn parse_string(mut self) -> Result<String, DeserializeError> {
        self.skip_whitespace();
        self.expect('"')?;
        let mut s = String::new();
        loop {
            match self.advance() {
                Some('"') => return Ok(s),
                Some('\\') => {
                    match self.advance() {
                        Some('"')  => s.push('"'),
                        Some('\\') => s.push('\\'),
                        Some('/')  => s.push('/'),
                        Some('n')  => s.push('\n'),
                        Some('r')  => s.push('\r'),
                        Some('t')  => s.push('\t'),
                        Some('u')  => {
                            let mut hex = String::new();
                            for _ in 0..4 {
                                hex.push(self.advance().ok_or(DeserializeError::Eof)?);
                            }
                            let code = u32::from_str_radix(&hex, 16)
                                .map_err(|_| DeserializeError::Message(format!("invalid unicode escape")))?;
                            if let Some(c) = char::from_u32(code) {
                                s.push(c);
                            }
                        }
                        _ => return Err(DeserializeError::Message(String::from("invalid escape"))),
                    }
                }
                Some(c) => s.push(c),
                None => return Err(DeserializeError::Eof),
            }
        }
    }

    fn parse_number(mut self) -> Result<f64, DeserializeError> {
        self.skip_whitespace();
        let start = self.pos;
        if self.pos < self.input.len() && self.input[self.pos] == '-' {
            self.pos = self.pos + 1;
        }
        while self.pos < self.input.len() && self.input[self.pos].is_ascii_digit() {
            self.pos = self.pos + 1;
        }
        if self.pos < self.input.len() && self.input[self.pos] == '.' {
            self.pos = self.pos + 1;
            while self.pos < self.input.len() && self.input[self.pos].is_ascii_digit() {
                self.pos = self.pos + 1;
            }
        }
        if self.pos < self.input.len() && (self.input[self.pos] == 'e' || self.input[self.pos] == 'E') {
            self.pos = self.pos + 1;
            if self.pos < self.input.len() && (self.input[self.pos] == '+' || self.input[self.pos] == '-') {
                self.pos = self.pos + 1;
            }
            while self.pos < self.input.len() && self.input[self.pos].is_ascii_digit() {
                self.pos = self.pos + 1;
            }
        }
        let num_str: String = self.input[start..self.pos].iter().collect();
        num_str.parse::<f64>()
            .map_err(|_| DeserializeError::Message(format!("invalid number: {}", num_str)))
    }

    fn parse_bool(mut self) -> Result<bool, DeserializeError> {
        self.skip_whitespace();
        if self.input[self.pos..].starts_with(&['t', 'r', 'u', 'e']) {
            self.pos = self.pos + 4;
            Ok(true)
        } else if self.input[self.pos..].starts_with(&['f', 'a', 'l', 's', 'e']) {
            self.pos = self.pos + 5;
            Ok(false)
        } else {
            Err(DeserializeError::Message(String::from("expected bool")))
        }
    }

    fn parse_null(mut self) -> Result<JsonValue, DeserializeError> {
        self.skip_whitespace();
        if self.input[self.pos..].starts_with(&['n', 'u', 'l', 'l']) {
            self.pos = self.pos + 4;
            Ok(JsonValue::Null)
        } else {
            Err(DeserializeError::Message(String::from("expected null")))
        }
    }

    fn parse_array(mut self) -> Result<JsonValue, DeserializeError> {
        self.expect('[')?;
        let mut items = Vec::new();
        self.skip_whitespace();
        if self.peek() == Some(']') {
            self.advance();
            return Ok(JsonValue::Array(items));
        }
        loop {
            items.push(self.parse_value()?);
            self.skip_whitespace();
            match self.peek() {
                Some(',') => { self.advance(); }
                Some(']') => { self.advance(); return Ok(JsonValue::Array(items)); }
                _ => return Err(DeserializeError::Message(String::from("expected ',' or ']'"))),
            }
        }
    }

    fn parse_object(mut self) -> Result<JsonValue, DeserializeError> {
        self.expect('{')?;
        let mut pairs = Vec::new();
        self.skip_whitespace();
        if self.peek() == Some('}') {
            self.advance();
            return Ok(JsonValue::Object(pairs));
        }
        loop {
            let key = self.parse_string()?;
            self.expect(':')?;
            let value = self.parse_value()?;
            pairs.push((key, value));
            self.skip_whitespace();
            match self.peek() {
                Some(',') => { self.advance(); }
                Some('}') => { self.advance(); return Ok(JsonValue::Object(pairs)); }
                _ => return Err(DeserializeError::Message(String::from("expected ',' or '}'"))),
            }
        }
    }
}

// ─── JSON Deserializer ──────────────────────────────────────

struct JsonDeserializer {
    value: JsonValue,
}

impl JsonDeserializer {
    fn new(value: JsonValue) -> JsonDeserializer {
        JsonDeserializer { value }
    }
}

impl Deserializer for JsonDeserializer {
    fn deserialize_bool(mut self) -> Result<bool, DeserializeError> {
        match &self.value {
            JsonValue::Bool(b) => Ok(*b),
            _ => Err(DeserializeError::InvalidType { expected: String::from("bool"), found: String::from("other") }),
        }
    }

    fn deserialize_i64(mut self) -> Result<i64, DeserializeError> {
        match &self.value {
            JsonValue::Number(n) => Ok(*n as i64),
            _ => Err(DeserializeError::InvalidType { expected: String::from("number"), found: String::from("other") }),
        }
    }

    fn deserialize_u64(mut self) -> Result<u64, DeserializeError> {
        match &self.value {
            JsonValue::Number(n) => Ok(*n as u64),
            _ => Err(DeserializeError::InvalidType { expected: String::from("number"), found: String::from("other") }),
        }
    }

    fn deserialize_f64(mut self) -> Result<f64, DeserializeError> {
        match &self.value {
            JsonValue::Number(n) => Ok(*n),
            _ => Err(DeserializeError::InvalidType { expected: String::from("number"), found: String::from("other") }),
        }
    }

    fn deserialize_str(mut self) -> Result<String, DeserializeError> {
        match &self.value {
            JsonValue::Str(s) => Ok(s.clone()),
            _ => Err(DeserializeError::InvalidType { expected: String::from("string"), found: String::from("other") }),
        }
    }

    fn deserialize_bytes(mut self) -> Result<Vec<u8>, DeserializeError> {
        match &self.value {
            JsonValue::Str(s) => crate::serial::binary::base64_decode(s)
                .map_err(|_| DeserializeError::Message(String::from("invalid base64"))),
            _ => Err(DeserializeError::InvalidType { expected: String::from("string"), found: String::from("other") }),
        }
    }

    fn deserialize_option<T: Deserialize>(mut self) -> Result<Option<T>, DeserializeError> {
        match &self.value {
            JsonValue::Null => Ok(None),
            _ => {
                let mut inner = JsonDeserializer::new(self.value.clone());
                T::deserialize(&mut inner).map(Some)
            }
        }
    }

    fn deserialize_seq<T: Deserialize>(mut self) -> Result<Vec<T>, DeserializeError> {
        match &self.value {
            JsonValue::Array(arr) => {
                let mut result = Vec::new();
                for item in arr {
                    let mut inner = JsonDeserializer::new(item.clone());
                    result.push(T::deserialize(&mut inner)?);
                }
                Ok(result)
            }
            _ => Err(DeserializeError::InvalidType { expected: String::from("array"), found: String::from("other") }),
        }
    }

    fn deserialize_map<K: Deserialize + Eq + Hash, V: Deserialize>(mut self) -> Result<HashMap<K, V>, DeserializeError> {
        match &self.value {
            JsonValue::Object(pairs) => {
                let mut map = HashMap::new();
                for (k, v) in pairs {
                    let mut kd = JsonDeserializer::new(JsonValue::Str(k.clone()));
                    let mut vd = JsonDeserializer::new(v.clone());
                    let key = K::deserialize(&mut kd)?;
                    let val = V::deserialize(&mut vd)?;
                    map.insert(key, val);
                }
                Ok(map)
            }
            _ => Err(DeserializeError::InvalidType { expected: String::from("object"), found: String::from("other") }),
        }
    }
}

/// Displays a JsonValue as a JSON string.
impl Display for JsonValue {
    fn fmt(self, f: &mut Formatter) -> Result<(), FmtError> {
        match self {
            JsonValue::Null => write!(f, "null"),
            JsonValue::Bool(b) => write!(f, "{}", if *b { "true" } else { "false" }),
            JsonValue::Number(n) => write!(f, "{}", n),
            JsonValue::Str(s) => write!(f, "\"{}\"", s),
            JsonValue::Array(arr) => {
                write!(f, "[")?;
                for (i, v) in arr.iter().enumerate() {
                    if i > 0 { write!(f, ",")?; }
                    write!(f, "{}", v)?;
                }
                write!(f, "]")
            }
            JsonValue::Object(pairs) => {
                write!(f, "{{")?;
                for (i, (k, v)) in pairs.iter().enumerate() {
                    if i > 0 { write!(f, ",")?; }
                    write!(f, "\"{}\":{}", k, v)?;
                }
                write!(f, "}}")
            }
        }
    }
}

// GreyStd Deterministic - Allocator
// Deterministic memory allocator for reproducible allocation patterns

// Create a deterministic pool allocator
fn PoolAllocator_new(pool_size) {
  {
    _type: "PoolAllocator",
    pool_size: pool_size,
    slots: map(range(0, pool_size), fn(_) { nil }),
    free_list: range(0, pool_size),
    allocated_count: 0,
    alloc_history: []
  }
}

// Allocate a slot
fn pool_alloc(alloc, value) {
  fn free() { get(alloc, "free_list") }
  if_then(eq(length(free()), 0),
    fn() { { handle: nil, allocator: alloc, error: "pool exhausted" } },
    fn() {
      fn slot() { get(free(), 0) }
      fn new_free() { slice(free(), 1) }
      fn new_slots() {
        map(range(0, get(alloc, "pool_size")), fn(i) {
          if_then(eq(i, slot()), fn() { value }, fn() { get(get(alloc, "slots"), i) })
        })
      }
      fn updated() {
        merge(alloc, {
          slots: new_slots(),
          free_list: new_free(),
          allocated_count: add(get(alloc, "allocated_count"), 1),
          alloc_history: append(get(alloc, "alloc_history"), { op: "alloc", slot: slot() })
        })
      }
      { handle: slot(), allocator: updated() }
    }
  )
}

// Free a slot
fn pool_free(alloc, handle) {
  fn new_slots() {
    map(range(0, get(alloc, "pool_size")), fn(i) {
      if_then(eq(i, handle), fn() { nil }, fn() { get(get(alloc, "slots"), i) })
    })
  }
  merge(alloc, {
    slots: new_slots(),
    free_list: append(get(alloc, "free_list"), handle),
    allocated_count: sub(get(alloc, "allocated_count"), 1),
    alloc_history: append(get(alloc, "alloc_history"), { op: "free", slot: handle })
  })
}

// Get value at a handle
fn pool_get(alloc, handle) {
  get(get(alloc, "slots"), handle)
}

// Set value at a handle
fn pool_set(alloc, handle, value) {
  fn new_slots() {
    map(range(0, get(alloc, "pool_size")), fn(i) {
      if_then(eq(i, handle), fn() { value }, fn() { get(get(alloc, "slots"), i) })
    })
  }
  merge(alloc, { slots: new_slots() })
}

// Get allocation count
fn pool_allocated(alloc) {
  get(alloc, "allocated_count")
}

// Get free count
fn pool_free_count(alloc) {
  length(get(alloc, "free_list"))
}

// Get pool capacity
fn pool_capacity(alloc) {
  get(alloc, "pool_size")
}

// Get allocation history (for deterministic replay)
fn pool_history(alloc) {
  get(alloc, "alloc_history")
}

// Reset allocator to initial state
fn pool_reset(alloc) {
  PoolAllocator_new(get(alloc, "pool_size"))
}

// Create a bump allocator (append-only, no individual free)
fn BumpAllocator_new(capacity) {
  {
    _type: "BumpAllocator",
    capacity: capacity,
    data: [],
    position: 0
  }
}

// Allocate in bump allocator
fn bump_alloc(alloc, value) {
  if_then(gte(get(alloc, "position"), get(alloc, "capacity")),
    fn() { { handle: nil, allocator: alloc, error: "bump allocator full" } },
    fn() {
      fn pos() { get(alloc, "position") }
      {
        handle: pos(),
        allocator: merge(alloc, {
          data: append(get(alloc, "data"), value),
          position: add(pos(), 1)
        })
      }
    }
  )
}

// Get from bump allocator
fn bump_get(alloc, handle) {
  get(get(alloc, "data"), handle)
}

// Get current position
fn bump_position(alloc) {
  get(alloc, "position")
}

// Reset bump allocator
fn bump_reset(alloc) {
  BumpAllocator_new(get(alloc, "capacity"))
}

// Get remaining capacity
fn bump_remaining(alloc) {
  sub(get(alloc, "capacity"), get(alloc, "position"))
}

// io::stream — Input/Output byte streams
//
// Stream protocol: objects with read/write functions.

// ── InputStream ─────────────────────────────────────────────────

// Creates an input stream from a string.
fn InputStream_from_string(s) {
    {
        _type: "InputStream",
        data: s,
        pos: 0,
        closed: false
    }
}

// Creates an input stream from an array of bytes.
fn InputStream_from_bytes(bytes) {
    {
        _type: "InputStream",
        data: bytes,
        pos: 0,
        closed: false
    }
}

// Reads n characters/bytes from the stream.
fn stream_read(stream, n) {
    fn pos() { get(stream, "pos") }
    fn data() { get(stream, "data") }
    fn available() { len(data()) - pos() }
    fn to_read() { min(n, available()) }
    if_then(to_read() <= 0,
        fn() { { data: nil, stream: stream } },
        fn() {
            fn chunk() { substr(data(), pos(), to_read()) }
            { data: chunk(), stream: set(stream, "pos", pos() + to_read()) }
        })
}

// Reads a single line from the stream.
fn stream_read_line(stream) {
    fn pos() { get(stream, "pos") }
    fn data() { get(stream, "data") }
    fn rest() { substr(data(), pos()) }
    fn newline_idx() { index_of(rest(), "\n") }
    if_then(newline_idx() < 0,
        fn() { { line: rest(), stream: set(stream, "pos", len(data())) } },
        fn() {
            fn line() { substr(rest(), 0, newline_idx()) }
            { line: line(), stream: set(stream, "pos", pos() + newline_idx() + 1) }
        })
}

// Reads all remaining data.
fn stream_read_all(stream) {
    fn pos() { get(stream, "pos") }
    fn data() { get(stream, "data") }
    { data: substr(data(), pos()), stream: set(stream, "pos", len(data())) }
}

// Returns true if the stream has reached the end.
fn stream_is_eof(stream) {
    get(stream, "pos") >= len(get(stream, "data"))
}

// Closes the stream.
fn stream_close(stream) { set(stream, "closed", true) }

// ── OutputStream ────────────────────────────────────────────────

// Creates an output stream.
fn OutputStream_new() {
    { _type: "OutputStream", buffer: "", closed: false }
}

// Writes data to the output stream.
fn stream_write(stream, data) {
    set(stream, "buffer", str(get(stream, "buffer"), data))
}

// Writes data followed by a newline.
fn stream_write_line(stream, data) {
    stream_write(stream, str(data, "\n"))
}

// Flushes and returns the buffer contents.
fn stream_flush(stream) {
    fn content() { get(stream, "buffer") }
    { data: content(), stream: set(stream, "buffer", "") }
}

// Returns the current buffer size.
fn stream_size(stream) {
    len(get(stream, "buffer"))
}
